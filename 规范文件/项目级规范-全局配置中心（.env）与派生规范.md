# CYP-Registry 项目级规范：全局配置中心（.env）与派生规则

**作者**：CYP | **联系方式**：nasDSSCYP@outlook.com | **版本**：v1.0.0 | **最后更新**：2026年2月24日

---

## 文档修订记录

|| 版本 | 日期 | 修订内容 | 修订人 |
||------|------|----------|--------|
|| v1.0.0 | 2026年2月24日 | 初始版本：定义 `.env` 单一配置中心与前后端/容器派生规则 | CYP |

---

> **重要提示**：本文档基于 CYP-Registry 项目的当前实现和技术栈（Go + Gin + Vue 3 + Docker）。在实际使用时，请根据项目的具体技术栈、框架版本、业务需求、部署环境和团队规范进行适当调整和适配。本文档提供的是参考实现和最佳实践，而非绝对标准。
> 
> **目标**：把"配置写哪里/怎么生效/怎么派生"一次性讲清楚，后续开发不再浪费时间反复对齐。

## 目录

- [1. 单一事实来源（Single Source of Truth）](#1-单一事实来源single-source-of-truth)
- [2. 派生关系（必须遵守）](#2-派生关系必须遵守)
- [3. 配置优先级（后端最终生效值）](#3-配置优先级后端最终生效值)
- [4. 键名规范（推荐 + 兼容）](#4-键名规范推荐--兼容)
- [5. “新增一个配置项”的标准流程](#5-新增一个配置项的标准流程)
- [6. 示例：新增一个“Trivy Server 地址”配置项](#6-示例新增一个trivy-server-地址配置项)
- [7. 全局错误收集器规范](#7-全局错误收集器规范)
- [8. 服务器关闭与数据清理规范](#8-服务器关闭与数据清理规范)

## 使用说明

### 一、适配核心原则

1. 单一事实来源：任何与运行环境相关的配置，应优先从根级 `.env` 出发进行建模与派生，禁止出现多个“真相源”（如多个不一致的 `.env`、`config.yaml`、前端 `.env`）。
2. 明确优先级：所有配置项必须能在“代码默认值 / config.yaml / 环境变量 / 容器 environment”这一优先级链条中找到归属，不允许出现“只有在某个脚本里写死”的情况。
3. 无副作用派生：从 `.env` 到前端、后端、容器的派生过程必须是可重复、幂等且无隐藏副作用的（仅根据输入生成目标文件，不混入临时逻辑）。

### 二、落地与维护方式

1. 首次落地：在新环境或新项目接入 CYP-Registry 时，应先根据本规范配置 `.env`、`config.yaml` 与 `docker-compose.*.yml` 的关系，并验证派生脚本（`auto-config.*`）执行结果。
2. 规则固化：将“新增/修改配置项”的流程固化为任务设计单中的必填部分，确保每次变更都经过 `.env` → 派生脚本 → 后端覆盖逻辑 → 文档更新的全链路。
3. 文档同步：当配置键名、默认值或派生逻辑发生调整时，除了更新代码与脚本，还必须更新本规范与 `docs/ENV.md`，保证新人可通过文档快速理解规则。

### 三、自查与培训

1. 自查频率：建议在每次大版本发布前，对照自查清单检查 `.env`、`config.yaml`、容器配置与前端环境变量是否保持一致。
2. 新人培训：新加入项目的开发者在修改任何配置前，必须阅读本规范指定章节，并通过一次“新增配置项”的完整演练。
3. 工具辅助：推荐在 CI 中加入简单的配置一致性检查（如对比 `.env` 与 `env.production.example` 的键集合），避免遗漏。

#### 规范自查清单（项目级配置中心）

为便于快速核验全局配置中心及其派生是否符合本规范，建议在附录中维护统一的《项目级配置中心自查清单》，按项目实际适配后逐项勾选确认。

## 1. 单一事实来源（Single Source of Truth）

- **唯一配置中心**：仓库根目录 `.env`
- **禁止**：前端、后端、docker-compose、脚本各写一份互相不一致的配置

## 2. 派生关系（必须遵守）

- **根级 `.env` → 前端 `web/.env.local`**
  - 由 `scripts/auto-config.sh` / `scripts/auto-config.ps1` 自动生成
  - 仅包含 `VITE_*`，前端只读 `VITE_*`
- **根级 `.env` → 后端运行时环境变量**
  - 后端读取 `config.yaml` 后，用环境变量覆盖（见 `src/pkg/config/config.go`）
- **根级 `.env` → 单镜像容器（All-in-One）**
  - `docker-compose.single.yml` 允许通过 `environment:` 显式覆盖 `.env`
  - **优先级**：容器显式 `environment` > `.env` > `config.yaml`

## 3. 配置优先级（后端最终生效值）

1. **环境变量**（容器 `environment` / 根级 `.env` 注入）
2. `config.yaml`
3. 代码默认值（仅当 `config.yaml` 不存在时使用）

## 4. 键名规范（推荐 + 兼容）

### 4.1 推荐命名（新键必须按此风格）

- `APP_*`：应用基础（如 `APP_HOST/APP_PORT/APP_ENV`）
- `APP_DB_*`：数据库（也兼容 `DB_*`）
- `APP_REDIS_*`：Redis（也兼容 `REDIS_*`）
- `APP_AUTH_*`：认证（也兼容历史 `JWT_*`）
- `APP_STORAGE_*`：存储（也兼容 `STORAGE_*`）
- `CLEANUP_ON_SHUTDOWN`：服务器关闭与清理配置（1=清理所有数据，0或不设置=保留数据）

### 4.2 当前项目已兼容的历史键（允许继续用，但新增请优先用推荐命名）

- **数据库**：`DB_HOST/DB_PORT/DB_USER/DB_PASSWORD/DB_NAME/DB_SSLMODE`
- **Redis**：`REDIS_HOST/REDIS_PORT/REDIS_PASSWORD/REDIS_DB`
- **JWT**：`JWT_SECRET`、`JWT_ACCESS_TOKEN_EXPIRE`、`JWT_REFRESH_TOKEN_EXPIRE`
- **存储**：
  - `STORAGE_TYPE`、`STORAGE_LOCAL_ROOT_PATH`
  - MinIO：`MINIO_ENDPOINT/MINIO_ACCESS_KEY/MINIO_SECRET_KEY/MINIO_BUCKET`
  - MinIO（另一套）：`STORAGE_MINIO_ENDPOINT/STORAGE_MINIO_ACCESS_KEY/...`
- **CORS**：`CORS_ALLOWED_ORIGINS`（逗号分隔，可覆盖 `config.yaml` 的 `security.cors.allowed_origins`）

## 5. “新增一个配置项”的最省事标准做法（强制流程）

当你需要新增任何配置项（比如新增一个第三方服务 URL），必须同时做完下面清单，否则会浪费后续联调/部署时间：

- **配置中心**：在根级 `.env` 增加键（通过脚本默认值/或 `env.production.example` 示例）
- **自动生成**：同步更新 `scripts/auto-config.sh` 与 `scripts/auto-config.ps1`
- **后端读取**：在 `src/pkg/config/applyEnvOverrides` 增加覆盖逻辑（或明确“不支持 env 覆盖”，必须写进 `config.yaml`）
- **文档同步**：更新 `docs/ENV.md`（说明键名、格式、默认值、是否敏感）
- **示例/生产模板**：更新 `env.production.example`
- **影响面说明**：在提交信息/变更说明里标注“影响范围”（前端/后端/部署）

# CYP-Registry 项目级规范：配置变更标准流程（含示例）

> 适用场景：新增/修改任何配置项（尤其是 `.env`、`config.yaml`、`docker-compose.*.yml`、`web/.env.local` 相关）。

## 1. 变更入口（唯一入口）

- **只允许从根级 `.env`（全局配置中心）发起配置变更**
- `config.yaml` 仅提供“可运行默认值”，生产/部署差异应尽量通过环境变量覆盖

## 2. 变更清单（提交前必须对照打勾）

- [ ] `.env`：增加/调整键名与默认值（必要时只在示例模板里体现，不要硬塞敏感值）
- [ ] `scripts/auto-config.sh`：补齐默认值/生成逻辑（幂等、不覆盖已有值）
- [ ] `scripts/auto-config.ps1`：同上（Windows 必须一致）
- [ ] `src/pkg/config/config.go`：补齐 `applyEnvOverrides`（否则写了不生效）
- [ ] `docs/ENV.md`：补齐说明（键名、格式、是否敏感、推荐值）
- [ ] `env.production.example`：补齐生产模板（含 CHANGE_ME 提示）
- [ ] 如影响前端：确认 `web/.env.local` 是否需要派生新 `VITE_*`（不要把敏感信息放进 VITE）

## 3. 示例：新增一个“Trivy Server 地址”配置项

### 3.1 需求

把当前写死在代码里的 `http://127.0.0.1:8082` 改成可配置：

- `.env` 使用 `TRIVY_SERVER_URL`
- 后端读取并覆盖默认值

### 3.2 应该怎么改（按顺序）

1. **全局配置中心**：在 `.env` 增加：
   - `TRIVY_SERVER_URL=http://127.0.0.1:8082`
2. **自动初始化**：在 `scripts/auto-config.*` 增加默认值（仅在 `.env` 不存在时写入）
3. **后端覆盖**：在 `applyEnvOverrides` 增加读取 `TRIVY_SERVER_URL` 并写入 `cfg.Scanner`（或 scanner service config）
4. **文档与模板**：更新 `docs/ENV.md` 与 `env.production.example`
5. **验证方式**：启动后在日志/健康检查输出当前 scanner 配置（不要输出敏感信息）

> 注意：这是"配置变更"的标准套路；任何新增键都按这个流程走，后续不会返工。

## 4. 全局错误收集器规范

> **重要提示**：以下规范基于当前项目（CYP-Registry）的实现，在实际使用时请根据项目的具体技术栈、框架版本、业务需求和运维环境进行适当调整和适配。
> 
> **目标**：确保所有错误（前端和后端）都能被正确捕获、记录和显示在调试台和容器日志中。

### 4.1 后端错误收集

#### 4.1.1 中间件顺序（必须遵守）

> **注意**：以下中间件顺序基于 Gin 框架的实现，如果使用其他框架（如 Echo、Fiber 等），请根据框架特性调整中间件注册顺序和方式。

后端错误处理中间件的注册顺序必须严格按照以下顺序，否则错误可能无法被正确捕获：

```go
// 1. Recovery中间件必须在最前面，用于捕获panic
r.Use(middleware.NewRecoveryMiddleware().Recovery())
// 2. RequestID中间件，生成请求追踪ID
r.Use(middleware.NewRequestIDMiddleware().RequestID())
// 3. 日志中间件，记录所有请求
r.Use(middleware.NewLoggerMiddleware(&cfg.Logging).Logger())
// 4. 全局错误处理中间件，捕获并记录所有错误
r.Use(middleware.NewErrorHandlerMiddleware().ErrorHandler())
// 5. CORS和安全头中间件
r.Use(middleware.NewCORSMiddleware(&cfg.Security.CORS).CORS())
r.Use(middleware.NewSecurityHeadersMiddleware().SecurityHeaders())
```

#### 4.1.2 日志输出格式

> **注意**：日志格式可根据项目需求进行调整，例如：
> - 如果使用结构化日志库（如 zerolog、zap），建议使用 JSON 格式
> - 如果需要集成日志收集系统（如 ELK、Loki），建议使用 JSON 格式便于解析
> - 如果仅用于本地开发调试，控制台格式更易读

后端错误日志支持两种格式（通过 `config.yaml` 的 `logging.format` 配置）：

- **JSON格式**（`logging.format: "json"`）：
  ```json
  {"timestamp":"2024-01-01T12:00:00Z","level":"error","trace_id":"abc12345","method":"GET","path":"/api/v1/users","status":500,"error":"错误消息","stack":"堆栈信息"}
  ```

- **控制台格式**（`logging.format: "console"` 或默认）：
  ```
  [ERROR] [abc12345] GET /api/v1/users 500 10ms 127.0.0.1 - Error: 错误消息
  Stack:
  堆栈信息
  ```

#### 4.1.3 错误类型处理

- **Panic错误**：由 `RecoveryMiddleware` 捕获，记录完整堆栈信息
- **业务错误**：由 `ErrorHandlerMiddleware` 捕获，支持 `CodeError` 类型
- **HTTP错误**：状态码 ≥ 400 的请求会被 `LoggerMiddleware` 记录为错误日志

#### 4.1.4 日志输出位置

> **注意**：日志输出位置应根据项目部署环境调整：
> - **容器化部署**：建议输出到 `stdout`，由容器编排系统（如 Kubernetes）收集
> - **传统部署**：可输出到文件，配合日志轮转工具（如 logrotate）
> - **云服务**：可集成云服务商的日志服务（如 AWS CloudWatch、阿里云日志服务）
> - **微服务架构**：建议使用集中式日志收集（如 ELK Stack、Grafana Loki）

- **开发环境**：输出到 `stdout`（控制台）
- **生产环境**：输出到 `stdout`（容器日志可通过 `docker logs` 查看）
- **文件日志**：通过 `config.yaml` 的 `logging.output: "file"` 配置（可选）

#### 4.1.5 配置项

在 `config.yaml` 中配置：

```yaml
logging:
  level: "info"                  # debug, info, warn, error
  format: "json"                   # json 或 console
  output: "stdout"                # stdout, file
  file:
    path: "./logs/app.log"
    max_size: 100                  # MB
    max_age: 30                    # 天
    max_backups: 10
  trace:
    enabled: true
    sample_rate: 1.0              # 采样率
```

### 4.2 前端错误收集

#### 4.2.1 全局错误处理器

> **注意**：以下错误处理器基于 Vue 3 框架，如果使用其他前端框架（如 React、Angular），请根据框架特性调整：
> - **React**：使用 `ErrorBoundary` 组件和全局错误处理
> - **Angular**：使用 `ErrorHandler` 服务
> - **原生 JavaScript**：使用 `window.onerror` 和 `unhandledrejection`

前端在 `web/src/main.ts` 中配置了以下全局错误处理器：

1. **Vue组件错误处理器**（`app.config.errorHandler`）
   - 捕获所有Vue组件渲染错误
   - 记录组件名称、错误信息、堆栈

2. **未处理的Promise拒绝处理器**（`unhandledrejection`）
   - 捕获所有未处理的Promise拒绝
   - 记录拒绝原因和堆栈

3. **全局JavaScript错误处理器**（`window.error`）
   - 捕获所有JavaScript运行时错误
   - 记录错误消息、文件名、行列号、堆栈

4. **资源加载错误处理器**（`error` 事件捕获阶段）
   - 捕获图片、CSS、JS等资源加载失败
   - 记录资源类型和URL

#### 4.2.2 错误日志格式

前端错误日志统一输出到浏览器控制台，格式如下：

```javascript
{
  error: "错误消息",
  stack: "错误堆栈",
  component: "组件名称",
  info: "Vue错误信息",
  timestamp: "2024-01-01T12:00:00.000Z",
  url: "https://example.com/path"
}
```

#### 4.2.3 错误输出位置

> **注意**：生产环境建议集成错误监控服务，根据项目需求选择：
> - **开源方案**：Sentry（自托管或云服务）、Bugsnag
> - **商业方案**：Datadog APM、New Relic、阿里云 ARMS
> - **自建方案**：将错误上报到后端API，统一收集和分析

- **开发环境**：浏览器开发者工具控制台（Console）
- **生产环境**：浏览器开发者工具控制台（Console）
- **建议**：生产环境可集成第三方错误监控服务（如Sentry）

### 4.3 错误追踪

#### 4.3.1 TraceID

> **注意**：TraceID 的生成方式和格式可根据项目需求调整：
> - **格式**：当前使用8位UUID，可根据需要改为完整UUID、雪花ID、或分布式追踪ID（如 OpenTelemetry TraceID）
> - **传递方式**：可通过 HTTP 头、响应体、或日志上下文传递
> - **分布式追踪**：如果使用微服务架构，建议使用 OpenTelemetry、Jaeger 等分布式追踪系统

- 每个请求都会生成唯一的 `TraceID`（8位UUID）
- TraceID 会出现在所有日志中，便于追踪同一请求的所有日志
- TraceID 会通过响应头 `X-Request-ID` 返回给客户端

#### 4.3.2 错误信息包含字段

后端错误日志必须包含以下字段：
- `timestamp`：时间戳（ISO 8601格式）
- `level`：日志级别（panic/error/warn/info）
- `trace_id`：请求追踪ID
- `method`：HTTP方法
- `path`：请求路径
- `status`：HTTP状态码（如有）
- `error`：错误消息
- `stack`：错误堆栈（如有）
- `ip`：客户端IP地址
- `user_agent`：用户代理（如有）

### 4.4 开发规范

#### 4.4.1 错误处理最佳实践

> **注意**：以下实践基于当前项目的实现，请根据项目使用的框架和库进行调整：
> - **错误类型**：根据项目需求定义错误类型和错误码体系
> - **错误响应格式**：确保前后端错误响应格式一致
> - **国际化**：如果项目支持多语言，错误消息需要国际化处理
> - **敏感信息**：生产环境不要暴露敏感错误信息（如数据库连接字符串、内部路径等）

1. **后端错误处理**：
   - 使用 `errors.NewCodeError()` 创建业务错误
   - 使用 `c.Error(err)` 添加错误到上下文
   - 使用 `response.Fail()` 返回错误响应
   - 不要直接 `panic`，除非是严重系统错误

2. **前端错误处理**：
   - 使用 `try-catch` 捕获异步操作错误
   - 使用 `Promise.catch()` 处理Promise错误
   - 在组件中使用 `onErrorCaptured` 捕获子组件错误
   - 不要忽略错误，至少记录到控制台

#### 4.4.2 调试建议

1. **查看后端日志**：
   ```bash
   # 查看容器日志
   docker logs <container_name> -f
   
   # 查看最近100行日志
   docker logs <container_name> --tail=100
   ```

2. **查看前端错误**：
   - 打开浏览器开发者工具（F12）
   - 切换到 Console 标签
   - 查看错误日志（红色标记）

3. **追踪错误**：
   - 使用 TraceID 在日志中搜索相关请求
   - 检查错误堆栈定位问题代码
   - 查看错误前后的请求日志

### 4.5 配置变更清单

当需要修改错误收集相关配置时，必须完成以下清单：

- [ ] 更新 `config.yaml` 中的 `logging` 配置（如需要）
- [ ] 更新 `src/middleware/auth.go` 中的日志格式（如需要）
- [ ] 更新 `src/middleware/error.go` 中的错误处理逻辑（如需要）
- [ ] 更新 `web/src/main.ts` 中的前端错误处理器（如需要）
- [ ] 更新本文档（如需要）
- [ ] 测试错误收集功能是否正常工作

### 4.6 验证方式

1. **后端错误测试**：
   - 在任意handler中触发panic：`panic("test error")`
   - 查看容器日志，应该能看到详细的错误信息和堆栈

2. **前端错误测试**：
   - 在组件中抛出错误：`throw new Error("test error")`
   - 打开浏览器控制台，应该能看到详细的错误信息

3. **HTTP错误测试**：
   - 访问不存在的路由（如 `/api/v1/notfound`）
   - 查看日志，应该能看到404错误记录

## 5. 服务器关闭与数据清理规范

> **重要提示**：以下规范基于当前项目（CYP-Registry）的实现，在实际使用时请根据项目的具体技术栈、部署环境和业务需求进行适当调整和适配。
> 
> **目标**：明确区分服务器停止和数据清理操作，确保数据安全和操作可控。

### 5.1 两种关闭模式

#### 5.1.1 停止模式（默认，保留数据）

**行为**：
- 关闭 HTTP 服务器
- 停止扫描器服务
- 关闭数据库连接池
- 关闭缓存连接
- **保留所有数据**（数据库、文件存储、缓存、上传文件）

**触发方式**：
- 发送 `SIGINT` 信号（Ctrl+C）
- 发送 `SIGTERM` 信号（`kill -TERM <pid>`）
- Docker 容器停止（`docker stop`）

**适用场景**：
- 正常维护和重启
- 更新服务器版本
- 临时停止服务
- 生产环境日常操作

#### 5.1.2 删除模式（清理所有数据）

**行为**：
- 执行停止模式的所有操作
- **清理数据库数据**（TRUNCATE 所有表，保留表结构）
- **清理文件存储**（删除所有镜像文件）
- **清理上传文件**（删除所有头像等上传文件）
- **清理缓存数据**（清空 Redis 缓存）

**触发方式**：
- 设置环境变量 `CLEANUP_ON_SHUTDOWN=1` 后发送停止信号

**适用场景**：
- 测试环境重置
- 开发环境清理
- 容器镜像重建前的清理
- 完全重置系统

**⚠️ 警告**：删除模式会**永久删除所有数据**，包括所有用户数据、项目数据、镜像文件、缓存数据，**此操作不可恢复！**

### 5.2 配置方式

#### 5.2.1 环境变量配置（全局配置中心）

**`CLEANUP_ON_SHUTDOWN` 由全局配置中心（根级 `.env` 文件）统一控制。**

在根级 `.env` 文件中添加：

```bash
# 服务器关闭时是否清理所有数据
# 1 = 清理所有数据（删除模式）
# 0 或不设置 = 保留数据（停止模式）
# ⚠️ 警告：设置为 1 时，关闭服务器会永久删除所有数据，此操作不可恢复！
CLEANUP_ON_SHUTDOWN=0
```

**配置说明**：
- 此配置项由全局配置中心（根级 `.env`）统一管理
- 容器启动时，`single-entrypoint.sh` 会自动从 `.env` 文件加载此环境变量
- 服务器启动时会自动检测并显示当前配置状态
- 修改配置后需要重启容器才能生效

#### 5.2.2 配置优先级

1. **容器环境变量**（`docker-compose.yml` 的 `environment`）- 最高优先级
2. **全局配置中心**（根级 `.env` 文件）- 推荐使用
3. **默认值**（不设置 = 保留数据）

#### 5.2.3 配置变更清单

当需要修改关闭和清理相关配置时，必须完成以下清单：

- [ ] 在根级 `.env` 中添加/更新 `CLEANUP_ON_SHUTDOWN` 配置
- [ ] 在 `env.production.example` 中添加示例配置
- [ ] 在 `docs/ENV.md` 中说明配置项（键名、格式、默认值、是否敏感）
- [ ] 在 `docs/SHUTDOWN_CLEANUP.md` 中更新详细说明（如需要）
- [ ] 更新本文档（如需要）

### 5.3 关闭流程规范

#### 5.3.1 停止模式流程

1. 接收停止信号（SIGINT/SIGTERM）
2. 停止扫描器服务（停止后台任务和队列）
3. 优雅关闭 HTTP 服务器（等待正在处理的请求完成，最多 10 秒超时）
4. 关闭缓存连接（Redis）
5. 关闭数据库连接池（PostgreSQL）
6. 完成关闭，**数据保留**

#### 5.3.2 删除模式流程

1. 接收停止信号（SIGINT/SIGTERM，且 `CLEANUP_ON_SHUTDOWN=1`）
2. 停止扫描器服务
3. 优雅关闭 HTTP 服务器
4. **清理数据库数据**（TRUNCATE 所有表，CASCADE 删除关联数据）
5. **清理文件存储**（删除所有存储文件：blobs、manifests、repositories）
6. **清理上传文件**（删除上传目录，重新创建空目录）
7. **清理缓存数据**（使用 SCAN 迭代删除所有 Redis 键）
8. 关闭缓存连接
9. 关闭数据库连接
10. 完成关闭，**所有数据已清理**

### 5.4 使用示例

#### 5.4.1 正常停止（保留数据）

```bash
# 启动服务器（默认保留数据）
./registry-server

# 在另一个终端停止（保留数据）
kill -TERM $(pgrep registry-server)

# Docker 容器停止（保留数据）
docker stop <container_name>
```

#### 5.4.2 停止并清理数据

```bash
# 启动服务器（设置清理标志）
CLEANUP_ON_SHUTDOWN=1 ./registry-server

# 在另一个终端停止（会清理所有数据）
kill -TERM $(pgrep registry-server)

# Docker 容器停止并清理
docker run -d \
  -e CLEANUP_ON_SHUTDOWN=1 \
  -v /data/storage:/data/storage \
  registry-server:latest
docker stop <container_id>
```

#### 5.4.3 docker-compose 配置

在 `docker-compose.yml` 中：

```yaml
services:
  registry-server:
    image: registry-server:latest
    environment:
      # 设置为 1 表示关闭时清理所有数据
      # 不设置或设置为 0 表示保留数据
      - CLEANUP_ON_SHUTDOWN=0
    volumes:
      - ./data/storage:/data/storage
      - ./data/db:/var/lib/postgresql/data
```

### 5.5 开发规范

#### 5.5.1 清理函数实现规范

所有清理函数必须遵循以下规范：

1. **错误处理**：
   - 清理失败应记录警告日志，但继续执行后续步骤
   - 不要因为单个清理步骤失败而中断整个关闭流程

2. **幂等性**：
   - 清理函数应该支持多次调用而不产生副作用
   - 如果资源已不存在，应静默返回成功

3. **日志记录**：
   - 每个清理步骤都应记录开始和完成日志
   - 失败时应记录详细的错误信息

4. **超时控制**：
   - 数据库清理应设置合理的超时时间
   - 文件清理应避免长时间阻塞

#### 5.5.2 代码位置

清理相关代码位于：
- `cmd/server/main.go`：关闭流程和清理函数
- `src/pkg/database/database.go`：数据库连接管理
- `src/pkg/cache/cache.go`：缓存连接管理

#### 5.5.3 新增清理项规范

当需要新增清理项时，必须：

1. 在 `cmd/server/main.go` 的关闭流程中添加清理步骤
2. 实现对应的清理函数（遵循 5.5.1 规范）
3. 在日志中明确标识清理步骤
4. 更新 `docs/SHUTDOWN_CLEANUP.md` 文档
5. 更新本文档

### 5.6 安全注意事项

1. **生产环境**：
   - **强烈建议**生产环境不要使用删除模式
   - 如果必须使用，确保已备份重要数据
   - 建议使用只读模式或备份模式进行数据保护

2. **权限控制**：
   - 确保服务器有权限删除存储目录和上传目录
   - 确保数据库用户有 TRUNCATE 权限

3. **数据备份**：
   - 在执行删除模式前，必须备份重要数据
   - 建议使用自动化备份工具（如 pg_dump、rsync）

4. **容器卷**：
   - 如果使用 Docker 卷挂载，删除模式不会删除卷中的数据文件
   - 需要手动删除卷或使用 `docker volume rm` 命令

### 5.7 验证方式

1. **停止模式验证**：
   ```bash
   # 启动服务器并创建一些数据
   ./registry-server
   # 创建用户、项目等数据
   
   # 停止服务器
   kill -TERM $(pgrep registry-server)
   
   # 重新启动，验证数据是否保留
   ./registry-server
   # 检查数据是否仍然存在
   ```

2. **删除模式验证**：
   ```bash
   # 启动服务器并创建一些数据
   CLEANUP_ON_SHUTDOWN=1 ./registry-server
   # 创建用户、项目等数据
   
   # 停止服务器（会清理数据）
   kill -TERM $(pgrep registry-server)
   
   # 重新启动，验证数据是否已清理
   CLEANUP_ON_SHUTDOWN=1 ./registry-server
   # 检查数据是否已被清理
   ```

3. **日志验证**：
   - 检查关闭日志，确认是否进入清理流程
   - 检查清理步骤的日志，确认每个步骤的执行情况
   - 检查是否有清理失败的警告

### 5.8 故障排查

#### 5.8.1 清理失败

**问题**：清理过程中出现错误

**排查步骤**：
1. 检查日志，确认具体失败的清理步骤
2. 检查文件系统权限
3. 检查数据库连接和权限
4. 检查存储目录是否存在且可写

#### 5.8.2 数据未清理

**问题**：设置了 `CLEANUP_ON_SHUTDOWN=1` 但数据未清理

**排查步骤**：
1. 检查环境变量是否正确设置
2. 检查日志确认是否进入清理流程
3. 检查清理函数的执行日志
4. 检查文件系统权限
5. 检查数据库权限（TRUNCATE 权限）

#### 5.8.3 容器卷数据未清理

**问题**：使用 Docker 卷时，删除模式未清理卷中的数据

**说明**：这是正常行为，删除模式只清理数据库记录和容器内的文件，不会删除挂载的卷。

**解决方案**：
```bash
# 手动删除卷
docker volume rm <volume_name>

# 或删除整个容器和卷
docker rm -v <container_name>
```

### 5.9 相关文档

- `docs/SHUTDOWN_CLEANUP.md`：详细的关闭和清理使用说明
- `docs/ENV.md`：环境变量配置说明（包含 `CLEANUP_ON_SHUTDOWN`）
- `cmd/server/main.go`：关闭流程实现代码


