# 全平台通用容器开发设计规范

|**作者**：CYP | **联系方式**：nasDSSCYP@outlook.com

|**规范目的**：本规范用于统一个人在全平台容器开发、自动配置（环境变量、数据库配置等）过程中的实施标准，确保容器具备跨平台兼容性、可复用性、安全性及自动化部署能力，适配网页端、管理端等多端应用的容器化需求。

|**适用范围**：覆盖Docker、Podman等主流容器引擎，兼容Linux、Windows、macOS全操作系统，适用于个人开发的各类应用容器化场景，包括开发环境、测试环境及生产环境的容器构建与配置管理。

|| 版本 | 日期 | 说明 |
||------|------|------|
|| v1.0.0 | 2026年2月24日 | 初始编制 |

---

## 文档修订记录

|| 版本 | 日期 | 修订内容 | 修订人 |
||------|------|----------|--------|
|| v1.0.0 | 2026年2月24日 | 初始版本：定义容器镜像、资源、网络、自动配置与CI/CD规范 | CYP |

---

提示：本规范为全平台通用容器开发设计基础框架，实际使用时请结合目标运行环境（本地开发、单机 Docker、Kubernetes 等）、应用类型与资源约束进行裁剪，避免在轻量级项目中引入过度复杂的容器编排方案。

## 目录

- [一、容器开发核心规范](#一容器开发核心规范)
- [二、自动配置规范](#二自动配置规范)
- [三、全平台适配规范](#三全平台适配规范)
- [四、Docker Compose最佳实践](#四docker-compose最佳实践)
- [五、容器调试与排障指南](#五容器调试与排障指南)
- [六、Windows容器特定配置](#六windows容器特定配置)
- [七、12-Factor应用容器化规范](#七12-factor应用容器化规范)
- [八、安全与优化规范](#八安全与优化规范)
- [九、容器监控与日志规范](#九容器监控与日志规范)
- [十、CI/CD容器集成规范](#十cicd容器集成规范)
- [十一、命令与脚本规范](#十一命令与脚本规范)
- [十二、附则](#十二附则)
- [附录：快速参考表](#附录快速参考表)
- [版本历史](#版本历史)

## 使用说明

### 一、适配核心原则

1. 环境适配：在个人开发、测试与生产环境中，应根据资源条件与部署方式选择合适的容器化策略（单容器/多容器、Compose/K8s），避免“一刀切”。
2. 配置中心优先：所有与环境相关的配置（端口、数据库、缓存、存储路径等）应尽量通过环境变量与配置中心管理，禁止硬编码在镜像内。
3. 安全与可观察性：容器规范必须同时考虑最小权限、健康检查、日志与监控接入，确保问题可被快速发现与定位。

### 二、落地与维护方式

1. 首次落地：为新项目设计容器方案时，应先从镜像选型、目录结构、资源限制与网络拓扑入手，再逐步引入自动配置与 CI/CD 集成。
2. 规则固化：将镜像构建规范、Compose 文件结构与自动配置脚本纳入仓库管理，通过脚本与 CI 检查避免手工偏差。
3. 文档同步：每次对容器运行方式（端口、资源、网络、卷挂载）做出重大调整时，应更新本规范对应章节与示例配置。

### 三、自查与培训

1. 自查频率：建议每次发布重要版本或调整基础设施时，对照自查清单审视当前容器设计是否仍然合理。
2. 新人培训：负责容器相关工作的开发者或运维在接手项目前，应通读本规范，并在测试环境中完成一次从构建镜像到上线的完整演练。
3. 工具辅助：鼓励使用容器扫描、资源监控与日志聚合等免费工具，辅助执行本规范，提升安全与运维效率。

#### 规范自查清单（容器开发设计）

为便于快速核验容器设计是否符合本规范，建议在附录中维护统一的《容器开发设计自查清单》，按项目实际适配后逐项勾选确认。

## 一、容器开发核心规范

### 1.1 基础镜像选型

- 遵循OCI开放容器格式标准，优先选用官方认证、轻量型基础镜像，优先选择Alpine、Debian Slim等精简镜像，减少镜像体积及安全隐患。避免使用未验证的第三方镜像，确需使用时需手动审计镜像依赖。

- 允许使用`latest`标签（含生产环境）。为确保可追溯与可回滚，使用`latest`时必须同时满足以下要求：
  - 变更可追溯：每次更新需记录“更新时间/触发方式/镜像摘要(digest)/回滚目标版本”，并保留历史记录；
  - 安全可控：更新前后必须执行镜像漏洞扫描（如Trivy），高危/严重漏洞可配置阻断发布；
  - 可回滚：必须保留上一可用版本镜像（按digest或tag），出现异常可一键回滚；
  - 兼容性验证：更新需先在测试环境验证（或灰度），通过后再进入生产；
  - 最小权限与最小暴露：即使使用`latest`，也必须满足非root运行、健康检查、端口最小暴露等生产约束。
  - 示例：允许`nginx:latest`，但必须在日志中记录本次实际运行的digest，必要时可回滚到上一digest。

- 跨架构适配需选择支持多CPU架构（amd64、arm64）的镜像，可通过Docker Buildx或Podman多架构构建功能实现全平台兼容。

### 1.2 镜像仓库与版本管理

- 配置镜像仓库自动检测机制，每小时执行一次检测任务，通过脚本校验仓库中镜像的版本更新、安全性漏洞及镜像完整性。检测工具可选用Trivy结合自定义Shell脚本，确保检测结果精准可追溯。

- 启用自动更新功能，检测到镜像更新后，自动拉取最新版本并替换旧镜像，更新过程需先在测试环境验证兼容性，再同步至生产环境，避免直接更新引发服务中断。

- 配置镜像加速策略，结合镜像仓库缓存、CDN加速或国内镜像源（如阿里云、腾讯云镜像加速器），优化镜像拉取速度；同时启用镜像分层缓存，减少重复拉取耗时，提升部署效率。

### 1.3 Dockerfile/Podmanfile编写规范

- 文件命名统一为`Dockerfile`（兼容Podman），首行指定基础镜像，后续指令按"构建依赖-应用部署-清理优化"顺序排列，减少镜像分层。

- 采用分层构建策略，将编译、依赖安装与应用打包分离，最终镜像仅保留运行时必要文件。示例如下：
  ```
  # 构建阶段
  FROM golang:1.22-alpine AS builder
  WORKDIR /app
  COPY go.mod go.sum ./
  RUN go mod download
  COPY . .
  RUN go build -o app ./main.go

  # 运行阶段
  FROM alpine:3.19
  WORKDIR /app
  COPY --from=builder /app/app ./
  EXPOSE 8080
  CMD ["./app"]
  ```

- **多阶段构建最佳实践**：
  - 构建阶段使用完整工具链镜像（如golang、node），运行阶段使用精简镜像（如alpine、scratch）
  - 尽量减少运行阶段的文件，仅复制必要二进制文件
  - 利用BuildKit缓存机制，优化增量构建速度

- 创建`.dockerignore`文件，排除不必要的文件，减少镜像体积和构建上下文：
  ```
  .git
  .gitignore
  README.md
  node_modules
  npm-debug.log
  Dockerfile
  .dockerignore
  *.log
  test/
  docs/
  ```

- 禁止在镜像中硬编码敏感信息（密钥、密码等），所有动态配置通过自动配置机制注入。

- 设置非root用户运行容器，通过`RUN adduser -D appuser`创建普通用户，再用`USER appuser`切换，提升容器安全性。

- 明确暴露容器端口（EXPOSE指令），仅暴露应用必需端口，避免端口滥用。

### 1.4 容器资源限制配置

- 基于应用需求设置CPU、内存资源的请求量（requests）和上限（limits），避免资源争抢或浪费。内存单位优先使用Ki、Mi、Gi（2进制），CPU单位用毫核（m）表示，示例：
        `# Docker Compose示例
services:
  app:
    image: myapp:v1.0
    deploy:
      resources:
        limits:
          cpus: '0.5' # 500m CPU
          memory: 128Mi
        reservations:
          cpus: '0.25' # 250m CPU
          memory: 64Mi`

- Windows环境下需适配Hyper-V隔离模式，Linux环境可启用Namespace隔离，确保跨平台资源隔离一致性。

### 1.5 容器生命周期管理

- 定义容器启动、停止、重启策略，通过`CMD`指定容器启动命令，`ENTRYPOINT`配置固定入口，支持参数动态传递。

- 配置健康检查探针，根据应用类型选择exec、HTTP或TCP方式，确保容器内应用正常运行。示例：
  ```
  HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1
  ```

- 配置优雅关闭（Graceful Shutdown），通过`STOPSIGNAL`指定终止信号（如SIGTERM），给予应用充足时间处理未完成请求后再退出，示例：
  ```
  STOPSIGNAL SIGTERM
  STOP_GRACE_PERIOD=30s
  ```

- 利用容器钩子（Hooks）机制，在容器启动前执行配置初始化脚本，停止后清理临时资源，适配OCI运行时规范。

- 生产环境中删除容器时，需联动清理残留文件及配置信息。通过自定义清理脚本（集成`docker rm -v`命令），自动删除容器关联的挂载目录、日志文件、临时配置文件；对于关联数据库的容器，需先备份核心数据，再清理数据库连接配置及冗余数据，避免残留信息占用资源或引发安全风险。

- 生产环境镜像删除需同步清理关联配置与数据库数据。删除镜像前先校验是否无运行/停止状态的关联容器，再通过脚本删除对应环境变量配置、镜像仓库元数据，以及容器生成的数据库表、缓存数据等，确保配置与数据链路完全清理，无残留冗余。

### 1.6 容器网络配置

- 采用自定义Bridge网络实现容器间通信，服务发现通过服务名自动解析，示例：
  ```yaml
  networks:
    app-network:
      driver: bridge
  services:
    app:
      networks:
        - app-network
    db:
      networks:
        - app-network
  ```

- 生产环境启用网络隔离，非必要容器禁止使用host网络模式，通过`network_mode: none`限制网络访问。

- 配置网络连接数限制，防止单个容器耗尽宿主机网络资源，可使用`--ulimit`参数或Docker配置：
  ```yaml
  ulimits:
    nofile:
      soft: 1024
      hard: 4096
  ```

- 端口映射规范：仅暴露应用必需端口，避免端口冲突，遵循"宿主机端口:容器端口"格式。

- 跨主机容器通信需配置Overlay网络或使用服务网格（如Traefik、Istio），确保跨节点网络可达性。

- 配置网络策略限制容器间非必要通信，最小化网络攻击面。

## 二、自动配置规范

### 2.1 全局配置中心（强制）

- **强制要求：所有项目必须使用“全局配置中心”作为唯一配置源（Single Source of Truth）**：
  - 全局配置中心可以是**单一配置仓库/单一配置文件集合**（如 `config/` 目录下的 YAML/JSON）、或轻量级本地配置服务，但对外表现为**统一管理入口**；
  - 禁止前端、后端、数据库、容器编排、脚本各自维护割裂的配置副本；任何配置变更必须先在全局配置中心完成，再由脚本/流水线同步到各端；
  - 全局配置中心至少要统一管理以下维度：
    - **环境维度**：dev / test / prod / local / 单机 / 云端 等环境标识；
    - **后端配置**：应用基础配置、数据库、Redis、对象存储、认证、日志、安全策略等；
    - **前端配置**：后端 API 基地址、环境标识、开关项（如是否启用扫描器）、CDN/静态资源地址等；
    - **数据库与存储**：连接字符串、连接池参数、迁移策略、初始化脚本位置；
    - **接口与网关**：统一网关地址、公共前缀（如 `/api/v1`）、CORS 策略；
    - **容器/部署**：端口映射、资源限制、数据卷路径、健康检查端点等；
  - 所有下游配置（后端 `config.yaml`、前端 `.env` / `config.ts`、`docker-compose.*.yml`、K8s YAML、CI/CD 变量等）**必须由全局配置中心派生或引用**，禁止手工在多处“各写一份”。

- **全局配置中心实现建议（个人项目约定）**：
  - **根级 `.env` 作为全局配置中心载体（当前项目默认实现）**：
    - 仓库根目录下的 `.env` 文件承担全局配置中心职责，集中维护应用、前端、后端、数据库、环境、接口网关等核心配置；
    - 该文件由跨平台自动配置脚本统一生成/初始化：`scripts/auto-config.sh`（Linux/macOS）与 `scripts/auto-config.ps1`（Windows）；
    - `.env` 生成后，可作为前后端、容器编排、CI/CD 等的统一配置输入源。
  - 复杂项目亦可采用目录化结构，将 `.env` 与 `config/*.yaml` 等组合使用，例如：
    - `config/global.yaml`：跨环境通用配置（项目名、端口约定、API 前缀等）；
    - `config/env.dev.yaml` / `config/env.prod.yaml`：环境差异配置（域名、数据库地址等）；
    - `config/frontend.env.tpl` / `config/backend.env.tpl`：用于生成前后端 `.env` 的模板；
  - 配置中心的变更需通过 Git 版本管理，并在提交信息中说明“影响范围”（前端/后端/数据库/部署等）。

- **前后端/数据库/容器对全局配置中心的消费方式**：
  - **后端**：
    - 通过统一的配置加载模块（如 Go 的 `config` 包）优先加载全局配置中心派生的 `config.yaml` 与环境变量；
    - `applyEnvOverrides` 仅作为环境级覆盖层，不得引入与全局配置中心不一致的新键名；
  - **前端**：
    - 所有可配置项（如 API 地址、环境标签、功能开关）必须来自生成的前端配置文件，不允许在组件/页面内硬编码 URL/环境名；
  - **数据库/Redis 等后端服务**：
    - 连接信息、连接池参数由全局配置中心管理，通过环境变量或配置文件注入，不在应用代码中硬编码；
  - **容器/脚本**：
    - 启动脚本、Compose、K8s 清单仅从配置中心衍生的 `.env` / YAML 中读取配置，不直接写死业务参数。

- **配置中心三大能力定义：自动检测 / 自动配置 / 自动初始化（强制）**
  - **自动检测（Auto Detect）**：
    - 在任意环境（宿主机、容器、NAS、Windows 等）启动前，通过检测脚本自动识别运行环境类型、网络/端口占用、基础依赖是否可用；
    - 检测结果用于判断是否需要调整配置（如端口、主机名、数据库/Redis 地址等），并在日志/报告中给出明确提示；
    - 检测阶段**不直接写入业务配置**，只负责收集环境事实，为后续自动配置决策提供输入。
  - **自动配置（Auto Configure）**：
    - 基于“全局配置中心 + 自动检测结果”，自动生成或更新配置内容，例如为不同环境选择合适的 API 基址、数据库主机、CORS 源等；
    - 自动配置必须通过统一脚本（如 `scripts/auto-config.*` / `generate-config.*`）完成，禁止在前端/后端/容器脚本内各自拼装关键配置；
    - 任何自动配置行为都必须保持**幂等**：多次执行不会破坏已存在且有效的用户配置（如已有 `.env` 时只补全缺失项）。
  - **自动初始化（Auto Init）**：
    - 在全局配置中心首次就绪后，自动为各端生成其专属配置文件/环境变量（如前端 `web/.env.local`、后端 `config.yaml`、Compose 使用的 `env_file` 等），确保“生成完即可直接启动”；
    - 自动初始化只在目标文件不存在时执行，并在文件头注明“由配置中心自动生成”、生成时间、以及不建议手动修改的说明；
    - 自动初始化完成后，任何端侧（前端、后端、容器、脚本）均不得再新增与配置中心不一致的新键名或硬编码常量，所有变更都必须回归到全局配置中心完成。

- **全局配置中心配置完成后的自动初始化（强制要求）**：
  - 自动配置脚本在完成全局配置中心初始化后，必须**自动派生并初始化各端配置**，至少包括：
    - 为前端生成专用环境文件（如 `web/.env.local`），只暴露 `VITE_*` 等前端可见变量，其内容直接来源于根级 `.env` 中的应用名、环境、API 基地址等字段；
    - 为后端/容器准备环境变量文件或配置文件（如 `.env`、`config.yaml`、`docker-compose.*.yml` 中的 `env_file` 引用），避免重复手写；
  - 自动初始化流程必须满足：
    - 幂等：目标文件存在时不得强行覆盖，只在缺失时初始化；
    - 可追溯：生成文件头部需注明“由全局配置中心自动生成”、生成时间以及不要直接修改的说明；
    - 一致性：各端配置的来源字段必须在文档中明确对应关系，确保任意一处行为可追溯到全局配置中心中的具体键名。

### 2.2 环境变量配置

- 环境变量命名统一采用"应用前缀_模块_变量名"格式，全大写字母+下划线分隔，例如`APP_DB_HOST`、`APP_LOG_LEVEL`，避免命名冲突。

- 敏感环境变量（数据库密码、API密钥等）禁止嵌入镜像或配置文件，通过容器引擎 Secrets 机制（Docker Secrets、Podman Secrets）或宿主机环境变量注入，生产环境需加密存储。

- 环境变量分类管理，按开发、测试、生产环境创建独立配置文件（如`.env.dev`、`.env.prod`），文件纳入版本控制（敏感信息除外），通过启动命令指定配置文件：
            `docker run --env-file .env.prod -d myapp:v1.0`

- 设置环境变量默认值，确保容器在未传入变量时仍能正常启动（适用于非核心配置），示例：`ENV APP_PORT=8080`。

- **强制要求：全平台自动配置（任何环境/任何平台/任何系统）**
  - 必须提供跨平台自动配置脚本：Windows PowerShell（`.ps1`）与 Linux/macOS Shell（`.sh`）两套；
  - 自动配置脚本必须满足：
    - 首次启动自动生成可运行配置（如生成 `.env` / 输出建议配置）；
    - 不覆盖已有配置（幂等，可重复执行）；
    - 生成的敏感值（如JWT密钥）必须为随机值，并提示生产环境替换；
    - 对关键配置必须做校验与提示（缺失时给出明确错误信息/修复建议）；
  - 启动入口（脚本或entrypoint）必须在启动前调用自动配置与检测流程，确保用户无需手工查找变量名即可启动。

- **容器内环境自动检测（只读，严格以全局配置中心为准）**
  - 容器内必须提供统一的环境检测脚本（如`detect-container-env.sh`），在应用进程启动前执行；
  - 检测脚本**只读取并验证当前进程环境变量**，不得在检测阶段自行写入/修改关键业务配置（包括 APP\_*/DB\_*/REDIS\_* 等），以避免产生独立于全局配置中心的“第二套真相”；
  - 当发现缺失或不合理的环境变量时，检测脚本仅打印明确告警（如“请检查全局配置中心 .env/部署配置”），并由上游配置中心或启动脚本负责真正的默认值注入或修复；
  - 默认值的定义与注入应由全局配置中心及其自动配置脚本负责，检测脚本只承担“对照配置中心的镜像视图进行健康体检”的职责。

### 2.3 生产环境启动前自动检查

- 生产环境中，无论运行于何种设备（物理机、云服务器、NAS）或操作系统，容器登录成功前需执行全量自动检查流程，通过初始化脚本前置校验，确保所有依赖与配置就绪后再允许登录操作。

- 检查范围包括：宿主机与容器网络连通性、数据库服务可用性、依赖服务（如缓存、消息队列）运行状态、配置文件完整性与权限、存储目录可读写性、镜像版本一致性，以及资源配额是否满足运行需求。

- 检查未通过时自动加载缺失配置或修复异常（如重新挂载存储、同步配置文件、重启依赖服务），修复失败则阻断登录并输出详细异常日志；检查通过后自动加载核心配置与依赖资源，确保容器登录后可正常提供服务。

### 2.4 数据库配置

- 数据库连接信息（地址、端口、用户名、密码）全部通过环境变量注入，应用程序读取环境变量生成连接配置，支持多数据库类型适配（MySQL、PostgreSQL等）。

- 配置数据库连接池参数（最大连接数、空闲连接数、超时时间），通过环境变量动态调整，适配不同环境资源规模，示例：`ENV DB_MAX_CONNS=20`。

- 数据库初始化脚本（表结构创建、测试数据导入）放入容器`/init`目录，通过启动脚本自动执行，仅在首次启动时运行，避免重复执行导致数据异常。

- 跨平台数据库适配需注意网络配置，容器内通过服务名或宿主机IP访问数据库，Windows环境下需适配容器与宿主机的网络桥接模式。

- **单镜像/单容器场景下的内置数据库默认配置要求**
  - 对于内置数据库（如容器内自带PostgreSQL实例），**默认值的定义必须归属于全局配置中心/启动脚本**，而非容器内检测脚本：
    - 例如单镜像入口脚本可在未显式传入数据库环境变量时，将 `DB_HOST` 默认设为 `127.0.0.1`、`DB_PORT` 默认设为 `5432` 并导出；
  - 环境检测脚本在发现缺失数据库配置时，仅负责：
    - 输出“数据库配置未设置（DB\_HOST 为空），请检查全局配置中心 .env 中的数据库相关配置”等提示；
    - 使用当前已有的环境变量值进行连通性测试并报告结果，而不再擅自修改 `DB_HOST/DB_PORT`；
  - 应用配置层需支持通过规范命名（如`APP_DB_HOST`、`APP_DB_PORT`）覆盖YAML/静态配置，以环境变量为最高优先级，保证“可通过单条`docker run`命令完全配置数据库连接”，并确保检测脚本观测到的 host/port 与应用实际使用的一致。

### 2.5 配置文件自动加载

- 应用配置文件采用模板化管理（如`config.tpl`），通过环境变量替换模板中的占位符，启动时生成最终配置文件，工具可选用envsubst、gomplate等轻量工具。

- 配置文件路径统一规范，容器内配置文件存放于`/app/config`目录，宿主机配置文件通过目录挂载方式注入，便于本地调试修改：
        `docker run -v $(pwd)/config:/app/config -d myapp:v1.0`

- 支持配置热更新，开发环境通过挂载配置文件实时生效，生产环境通过重启容器或应用内配置刷新机制更新，避免影响服务可用性。

### 2.6 数据持久化配置

- 容器数据采用Volume或Bind Mount持久化，禁止将数据存储于容器可写层，避免容器删除导致数据丢失。

- 数据库等有状态服务必须使用命名Volume，便于备份和迁移，示例：
  ```yaml
  volumes:
    - db-data:/var/lib/mysql
  volumes:
    db-data:
  ```

- 关键数据目录配置只读挂载，防止容器误删数据，示例：
  ```bash
  docker run -v /host/config:/app/config:ro -d myapp:v1.0
  ```

- 临时数据使用tmpfs挂载，提升性能且不持久化：
  ```yaml
  tmpfs:
    - /run/cache
  ```

- 定期执行数据备份任务，备份文件独立存储于宿主机或对象存储，建议每日增量备份、每周全量备份。

- 数据恢复流程需文档化，包含恢复步骤、验证方法及回滚方案，确保灾难恢复能力。

## 三、全平台适配规范

### 3.1 容器引擎兼容性

- 优先使用Docker与Podman通用命令，避免使用引擎专属特性（如Docker Daemon命令），确保容器在两种引擎下均可正常构建、运行。

- Windows环境下需注意文件路径格式，采用跨平台路径表示法（如`/app`而非`C:\app`），挂载目录时适配Windows路径转换（如`$(pwd)`替换为`%cd%`）。

- macOS环境下容器内存限制需适配Docker Desktop的资源分配上限，避免因内存不足导致容器崩溃。

### 3.2 开发环境容器化适配

- 采用Dev Containers规范配置开发环境，创建`.devcontainer.json`文件定义开发容器配置，集成VS Code Remote - Containers扩展，实现本地与容器开发环境一致。

- 开发环境容器挂载本地代码目录，启用热重载功能，代码修改后自动同步至容器并重启应用，提升开发效率。

- 开发阶段启用依赖加速自动配置机制，容器启动时自动检测测试所需依赖类型（如npm、pip、maven等），结合当前网络环境自动选择最优镜像源（国内优先适配阿里云、华为云依赖源），无需手动配置；同时缓存依赖包至本地或NAS，减少重复下载耗时。

### 3.3 跨平台环境自动配置

- 实现宿主机及环境配置的自动检测与适配，通过Shell/PowerShell脚本联动Ansible轻量工具，自动识别运行环境（容器、NAS、Windows、Linux云服务器、macOS），检测宿主机硬件资源、操作系统版本、网络配置及存储路径。

- 根据检测结果自动配置环境参数：容器环境适配对应的引擎配置，NAS环境自动挂载存储目录并配置权限，Windows环境调整路径格式与网络桥接模式，云服务器适配厂商专属网络（如阿里云VPC、腾讯云私有网络），确保全平台环境配置一致性。

- 自动同步核心配置至目标环境，包括环境变量、数据库连接信息、存储策略等，适配不同平台的配置文件格式，避免手动配置遗漏或错误。

- **跨平台检测脚本示例**：通过多语言脚本组合实现精准检测，集成交叉验证与容错逻辑，以下为核心脚本片段（可按实际场景扩展）：
            1. Linux/云服务器/容器环境检测（Shell脚本）`#!/bin/bash
# 系统版本检测（主备命令交叉验证）
if command -v lsb_release &> /dev/null; then
  OS_VERSION=$(lsb_release -a | grep "Description" | awk -F: '{print $2}' | sed 's/^ //')
else
  OS_VERSION=$(cat /etc/os-release | grep "PRETTY_NAME" | cut -d'"' -f2)
fi

# 硬件资源检测（统一单位为Gi）
CPU_INFO=$(lscpu | grep "Model name" | awk -F: '{print $2}' | sed 's/^ //')
MEM_TOTAL=$(free -m | grep Mem | awk '{print $2 / 1024}' | awk '{printf "%.2fGi", $1}')

# 容器环境判断
if [ -f /proc/1/cgroup ] && grep -q "docker\|podman" /proc/1/cgroup; then
  ENV_TYPE="Container"
else
  ENV_TYPE="Host"
fi

# Ansible缓存配置（提升重复检测效率）
cat > /etc/ansible/ansible.cfg << EOF
[defaults]
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_cache
fact_caching_timeout = 3600  # 缓存1小时，减少重复检测
EOF

# 输出结构化检测报告
echo "{\"os_version\":\"$OS_VERSION\",\"cpu_info\":\"$CPU_INFO\",\"mem_total\":\"$MEM_TOTAL\",\"env_type\":\"$ENV_TYPE\"}" > /tmp/env_detect_report.json
            `2. Windows环境检测（PowerShell脚本）`# 硬件资源检测（精准提取并统一单位）
$cpuInfo = (Get-CimInstance Win32_Processor).Name | Select-Object -Unique
$ramRaw = Get-CimInstance Win32_PhysicalMemory
$memTotal = [math]::Round(($ramRaw | Measure-Object -Property Capacity -Sum).Sum / 1GB, 2)
$osVersion = (Get-CimInstance Win32_OperatingSystem).Caption

# 网络配置检测
$ipAddress = (Get-NetIPAddress | Where-Object { $_.AddressFamily -eq "IPv4" -and $_.InterfaceAlias -notlike "*Loopback*" }).IPAddress | Select-Object -First 1

# 生成检测报告
$report = [PSCustomObject]@{
  OSVersion = $osVersion
  CPUInfo   = $cpuInfo
  MemTotal  = "$memTotal GiB"
  IPAddress = $ipAddress
  EnvType   = "Windows Host"
}
$report | ConvertTo-Json -Depth 10 | Out-File -FilePath "$env:TEMP\env_detect_report.json"
           `3. NAS环境检测（适配群晖/威联通，Shell脚本）`#!/bin/bash
# NAS型号与系统版本检测
if command -v synogear &> /dev/null; then
  NAS_MODEL="Synology"
  OS_VERSION=$(cat /etc/version)
else
  NAS_MODEL="QNAP"
  OS_VERSION=$(getcfg system version)
fi

# 存储路径检测与权限配置
STORAGE_PATH="/volume1/docker"
if [ ! -d "$STORAGE_PATH" ]; then
  mkdir -p "$STORAGE_PATH"
  chmod 755 "$STORAGE_PATH"  # 自动创建并配置权限
else
  # 确保已存在目录的权限正确（遵循权限规范）
  chmod 755 "$STORAGE_PATH" 2>/dev/null || echo "WARN: Failed to set directory permissions"
fi

# 输出检测结果
echo "NAS Model: $NAS_MODEL"
echo "OS Version: $OS_VERSION"
echo "Storage Path: $STORAGE_PATH (Permission: $(stat -c "%a" $STORAGE_PATH))"
` `            `

- **检测准确性保障补充**：脚本执行时启用异常捕获（Shell用`set -e`、PowerShell用`try-catch`），对检测结果模糊项（如NAS型号、容器引擎类型）通过正则匹配二次校验；Ansible启用事实缓存后，每小时同步一次缓存数据，既减少重复检测耗时，又确保配置信息实时性，缓存文件定期清理避免冗余。

## 四、Docker Compose最佳实践

### 4.1 Compose文件结构规范

- 采用版本化Compose文件（version: "3.8"及以上），使用YAML格式，文件命名为`docker-compose.yml`或`compose.yaml`，统一纳入版本控制。

- 使用扩展字段`x-`定义公共配置，实现配置复用，避免重复定义：
  ```yaml
  x-app-common: &app-common
    restart: unless-stopped
    networks:
      - app-network
    logging:
      &app-logging
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  services:
    app:
      <<: *app-common
      image: myapp:v1.0
  ```

- 按服务类型分组配置，使用注释清晰标注各服务用途，保持配置文件可读性。

### 4.2 服务依赖与启动顺序

- 使用`depends_on`定义服务依赖关系，确保数据库等基础服务先于应用启动：
  ```yaml
  services:
    app:
      image: myapp:v1.0
      depends_on:
        db:
          condition: service_healthy
        redis:
          condition: service_started
    db:
      image: postgres:15-alpine
      healthcheck:
        test: ["CMD-SHELL", "pg_isready -U postgres"]
        interval: 5s
        timeout: 5s
        retries: 5
  ```

- 关键服务配置健康检查，通过`condition`参数控制依赖服务就绪状态，避免应用启动时连接失败。

### 4.3 环境隔离与配置管理

- 使用多个Compose文件适配不同环境，通过`-f`参数指定配置文件：
  ```bash
  # 开发环境
  docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d

  # 生产环境
  docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
  ```

- 环境变量文件命名规范：`.env`（基础配置）、`.env.dev`（开发）、`.env.prod`（生产）。单镜像模式推荐统一使用 `.env` + `docker-compose.single.yml`，敏感信息通过 `.env` 或 Secrets 注入。

- 生产环境禁用`volumes`挂载代码目录，确保镜像不可变，配置通过Config/Secrets注入。

### 4.4 资源管理与横向扩展

- 为每个服务明确资源配置，支持水平扩展：
  ```yaml
  services:
    app:
      image: myapp:v1.0
      deploy:
        replicas: 2
        resources:
          limits:
            cpus: '0.5'
            memory: 256Mi
          reservations:
            cpus: '0.25'
            memory: 128Mi
  ```

- 使用`configs`和`secrets`管理敏感配置，生产环境优先使用外部存储：
  ```yaml
  configs:
    app_config:
      file: ./config/app.yml
  secrets:
    db_password:
      file: ./secrets/db_password.txt
  ```

### 4.5 Compose项目命名与隔离

- 通过`-p`参数指定项目名称，避免多项目命名冲突：
  ```bash
  docker-compose -p myproject-dev up -d
  ```

- 使用自定义网络名称确保服务间通信稳定，避免使用默认网络名称。

### 4.6 单镜像模式（All-in-One）规范（生产强制）

- **适用场景**：离线/单机/开发/**生产环境（唯一架构要求）**。所有个人项目一律采用“单镜像 + 单容器”形态运行。

- **强制原则（取代服务拆分方案）**：
  - **禁止服务拆分**：不允许将应用、数据库、缓存、存储等拆分到多个容器或多个镜像中运行，本规范下视为**不合规架构**；
  - **单镜像内聚合所有依赖**：数据库（PostgreSQL/SQLite 等）、缓存（Redis 或内存）、对象存储客户端、扫描器、定时任务等一律打包到同一个镜像/容器内，通过统一入口脚本启动；
  - **单容器即系统边界**：对外只暴露一个容器端口（或一组紧密相关端口），所有内部进程仅作为该容器内的子进程存在，不单独暴露为容器服务；

- **实现要求**：
  - **统一入口脚本**：必须使用入口脚本在容器内启动依赖进程（例如内置 Postgres、Redis）并等待就绪后再启动应用；
  - **首次启动初始化**：数据库初始化脚本必须做到幂等（marker 文件/检测表存在等），避免重复执行导致数据异常；
  - **数据持久化**：必须为数据库/缓存/业务存储分别提供可挂载的数据目录或命名卷，并在文档中写明默认路径；
  - **可观测性**：必须保留健康检查端点与关键日志输出到 stdout/stderr；
  - **安全约束**：应用进程必须以非 root 用户运行；入口脚本可临时以 root 修复挂载目录权限后降权；
  - **生产限制**：生产环境不建议使用单镜像模式（与 12-Factor “Backing Services 可替换”理念冲突），若必须使用，需额外评审并补齐备份/恢复/升级回滚方案。

- **容器内自动检测与本地依赖回退实现补充说明**：
  - 单镜像模式的入口脚本应在合适阶段调用容器内环境检测脚本（如`/app/scripts/detect-container-env.sh`），该脚本仅提供**检测与告警**能力，不负责真正的默认值回退，也不阻断启动流程；
  - 对于数据库/Redis 等本地依赖的“本地回退”（如回退到 `127.0.0.1:5432`、`127.0.0.1:6379`），应由：
    - 全局配置中心 `.env` 中的默认配置；
    - 以及单镜像入口脚本中的默认值逻辑共同决定，并通过 `export` 明确赋值；
  - 最终数据库/缓存的有效配置优先级为：**全局配置中心/启动脚本导出的显式环境变量 > 镜像内置静态配置（如`config.yaml`）**，检测脚本仅对这套配置进行健康体检和连通性报告，保证检测日志与应用实际使用的 host/port 一致。

- **生产环境验收测试清单（强制执行并留档）**：
  - **启动与自检**：容器启动后 60 秒内 `GET /health` 必须返回 200；启动日志需包含 DB/Redis 就绪信息。
  - **数据库**：首次启动自动初始化成功；重启容器后数据不丢失（至少验证：注册用户、创建项目仍存在）。
  - **认证**：`/api/v1/auth/register`、`/api/v1/auth/login`、`/api/v1/auth/refresh`、`/api/v1/auth/logout` 全链路可用。
  - **项目**：项目 CRUD、成员增删查可用（`/api/v1/projects...`）。
  - **Registry V2**：`/v2/`、`/v2/_catalog`、`/v2/<name>/manifests`、`/v2/<name>/blobs`、`/v2/auth` 可用；至少完成一次 `docker login` + `docker push` + `docker pull` 回归。
  - **扫描器**：`/api/v1/scans/sync` 至少可对指定镜像引用返回扫描结果（如不具备扫描条件，必须在部署说明中写明前置条件与降级策略）。
  - **Web UI**：同端口提供静态站点（SPA），前端路由刷新不 404。
  - **持久化目录/卷**：明确列出并验证：PostgreSQL 数据、Redis 数据、业务存储、日志目录均持久化。
  - **备份恢复**：至少提供并演练一次“导出 SQL 备份 -> 清空卷 -> 还原 -> 验证”流程（可脚本化）。
  - **资源基线**：记录 CPU/内存/磁盘占用基线，满足目标环境容量。

## 五、容器调试与排障指南

### 5.1 常用调试命令

- **容器日志查看**：实时查看容器输出，追踪问题根源
  ```bash
  # 实时日志
  docker logs -f <container_name>

  # 最近100行日志
  docker logs --tail 100 <container_name>

  # 带时间戳的日志
  docker logs -t <container_name>
  ```

- **容器内部操作**：进入容器排查问题
  ```bash
  # 使用exec执行命令
  docker exec -it <container_name> sh

  # 以指定用户身份执行
  docker exec -u appuser <container_name> ls -la /app
  ```

- **容器信息检查**：获取容器运行状态和配置
  ```bash
  # 容器详细信息
  docker inspect <container_name>

  # 容器资源使用情况
  docker stats <container_name>

  # 容器端口映射
  docker port <container_name>
  ```

### 5.2 常见问题排查

- **容器无法启动**：
  - 检查容器日志：`docker logs <container_id>`
  - 验证镜像是否存在：`docker images | grep <image_name>`
  - 确认端口是否被占用：`netstat -tuln | grep <port>`

- **容器启动后立即退出**：
  - 检查容器退出码：docker inspect --format='{{.State.ExitCode}}' <container>
  - 验证启动命令是否正确
  - 确认依赖服务是否就绪

- **容器网络不通**：
  - 检查容器网络：`docker network ls`
  - 查看网络详情：`docker network inspect <network_name>`
  - 测试容器间连通性：`docker exec <container> ping <other_container>`

- **镜像构建失败**：
  - 检查Dockerfile语法
  - 验证基础镜像是否存在
  - 确认构建上下文中的文件权限

### 5.3 性能问题诊断

- **内存泄漏排查**：使用`docker stats`监控内存使用趋势，结合应用级内存分析工具定位泄漏点。

- **CPU占用过高**：通过`docker top <container>`查看进程信息，使用`perf`或`strace`分析系统调用。

- **磁盘空间不足**：检查镜像、容器、卷占用：
  ```bash
  docker system df -v
  docker system prune -a  # 清理未使用的资源
  ```

## 六、Windows容器特定配置

### 6.1 Windows容器基础配置

- 使用Windows基础镜像时，需明确指定OS版本：
  ```dockerfile
  FROM mcr.microsoft.com/windows/servercore:ltsc2022
  ```

- Windows容器支持两种隔离模式：Hyper-V隔离和进程隔离，生产环境根据需求选择。

- 文件路径使用Windows格式，容器内路径分隔符为反斜杠`\`。

### 6.2 Windows环境变量与配置

- 环境变量通过`ENV`指令设置，注意Windows格式：
  ```dockerfile
  ENV APP_DATA=C:\app\data
  ENV PATH=C:\app;C:\app\bin;%PATH%
  ```

- 敏感配置通过Windows环境变量或Windows Secrets注入，避免硬编码。

### 6.3 Windows卷挂载与权限

- 挂载宿主机目录时使用Windows路径格式：
  ```powershell
  docker run -v "C:\data:C:\app\data" myapp:latest
  ```

- 注意Windows文件权限设置，容器进程通常以ContainerUser或ContainerAdministrator身份运行。

- Windows容器支持挂载SMB共享作为持久化存储，适用于分布式场景。

### 6.4 Windows网络配置

- Windows容器支持NAT、Transparent、Overlay等网络模式，NAT模式默认启用。

- 端口映射使用Windows防火墙规则，生产环境需配置入站规则。

- Windows容器与宿主机共享网络命名空间，通过localhost即可访问宿主机服务。

## 七、12-Factor应用容器化规范

### 7.1 代码基准（Codebase）

- 每个应用对应一个代码仓库，通过Git标签或分支区分环境（dev、staging、prod）。

- 镜像版本与代码版本严格对应，采用语义化版本或Git提交哈希作为镜像标签。

### 7.2 依赖管理（Dependencies）

- 应用依赖必须显式声明，禁止依赖系统级包管理器（apt、yum）安装的包。

- 使用包管理器锁定依赖版本，构建时独立下载，确保环境一致性。

- Dockerfile中清理构建工具，避免将编译依赖带入运行时镜像。

### 7.3 配置（Config）

- 配置与代码严格分离，所有环境差异通过环境变量注入。

- 敏感配置使用容器引擎Secrets机制，不写入镜像或环境变量文件。

- 区分部署配置（环境变量）与应用配置（配置文件），通过模板引擎动态生成。

### 7.4 后端服务（Backing Services）

- 数据库、缓存、消息队列等后端服务视为可替换资源，通过连接URL配置。

- 服务连接信息通过环境变量注入，应用内解析连接字符串。

- 支持服务发现机制，容器通过服务名自动发现依赖服务。

### 7.5 构建/发布/运行（Build, Release, Run）

- **构建阶段**：将代码编译为可执行产物，构建过程可复现、可审计。

- **发布阶段**：将构建产物生成不可变的镜像版本。

- **与运行环境结合，运行阶段**：使用发布产物启动容器，应用代码与运行环境 禁止在运行时修改容器内容，任何完全隔离。

-变更需通过重新构建镜像实现。

### 7.6 进程（Processes）

- 应用以一个或多个无状态进程运行，不依赖本地存储保存数据。

- 会话状态使用Redis等分布式缓存，文件存储使用持久化卷。

- 进程间通过内存共享或消息队列通信，避免文件系统共享。

### 7.7 端口绑定（Port Binding）

- 应用容器暴露单一端口，通过环境变量`PORT`指定监听端口。

- 容器编排系统负责端口映射和服务发现，对外提供统一访问入口。

- 同一宿主机上的多个容器使用不同宿主机端口，避免冲突。

### 7.8 并发（Concurrency）

- 通过容器水平扩展实现并发，而非进程内多线程。

- 容器编排系统负责负载均衡和流量分发。

- 无状态设计支持任意数量的容器实例横向扩展。

### 7.9 可处置性（Disposability）

- 应用需支持快速启动和优雅关闭，启动时间控制在30秒内。

- 优雅关闭通过捕获终止信号（SIGTERM），完成清理后自行退出。

- 消息队列消费者需处理完当前消息后再退出，避免消息丢失。

### 7.10 开发/生产平等（Dev/Prod Parity）

- 开发、测试、生产环境使用相同的容器镜像，仅配置不同。

- 使用Compose或Kubernetes实现本地开发环境与生产环境的一致性。

- 减少环境差异带来的"在我机器上能运行"问题。

### 7.11 日志（Logs）

- 应用日志输出至stdout/stderr，由容器引擎接管日志收集。

- 日志格式统一为结构化JSON，包含时间戳、级别、请求ID等字段。

- 生产环境使用集中式日志系统（如ELK、Loki）收集和分析日志。

### 7.12 管理进程（Admin Processes）

- 管理任务作为一次性进程运行，与应用进程使用相同镜像。

- 数据库迁移、日志分析等任务通过`docker exec`或独立容器执行。

- 管理进程同样遵循环境变量配置原则，确保与主应用配置一致。

## 八、安全与优化规范

### 8.1 容器安全

- 禁用容器特权模式（--privileged），仅在确有必要时授予最小权限，通过`--cap-add`添加特定能力而非全量特权。

- 镜像构建完成后清理构建依赖、临时文件，减少攻击面，示例：`RUN apk add --no-cache gcc && go build && apk del gcc`。

- 敏感目录（如配置目录、日志目录）设置合理权限，避免全局可写，示例：`RUN chmod 700 /app/config`。

- **目录与文件权限规范（强制）**：
  - **统一权限标准**：
    - 目录权限：`0755`（rwxr-xr-x），所有者可读写执行，组和其他用户可读执行
    - 文件权限：`0644`（rw-r--r--），所有者可读写，组和其他用户只读
    - 敏感目录权限：`0700`（rwx------），仅所有者可访问（如配置目录、密钥目录）
    - 可执行文件权限：`0755`（rwxr-xr-x），所有者可读写执行，组和其他用户可读执行
  - **权限设置流程**：
    - 创建目录时必须使用 `os.MkdirAll(path, 0755)` 或 `mkdir -p` 并指定权限
    - 创建目录后必须使用 `os.Chmod(path, 0755)` 或 `chmod` 确保权限正确（即使目录已存在）
    - 创建文件后必须使用 `os.Chmod(file, 0644)` 或 `chmod` 设置文件权限
    - 权限设置失败时应记录警告日志，但不中断流程（文件操作会自然失败并返回明确错误）
  - **容器环境权限处理**：
    - 优先使用 `/tmp` 目录（容器环境通常有写入权限）或通过 `UPLOADS_DIR` 环境变量指定可写目录
    - 所有目录路径必须转换为绝对路径（使用 `filepath.Abs()` 或 `realpath`），避免相对路径导致的权限问题
    - 启动前检查存储目录可读写性，权限不足时自动修复或使用备用目录
  - **权限错误处理**：
    - 权限设置失败时记录警告日志，提供明确的错误信息（如"权限不足"、"目录不存在"）
    - 文件写入失败时检查 `os.IsPermission(err)`，返回明确的权限错误信息
    - 容器启动时验证关键目录权限，权限不正确时尝试修复，修复失败则输出详细错误并提示修复方法
  - **代码实现示例**：
    ```go
    // 创建目录并确保权限
    if err := os.MkdirAll(dir, 0755); err != nil {
        return fmt.Errorf("failed to create directory: %w", err)
    }
    // 确保目录权限正确（即使目录已存在）
    if err := os.Chmod(dir, 0755); err != nil {
        log.Printf("WARN: failed to set directory permissions: %v", err)
    }
    
    // 创建文件并设置权限
    file, err := os.Create(path)
    if err != nil {
        if os.IsPermission(err) {
            return fmt.Errorf("permission denied: %w", err)
        }
        return fmt.Errorf("failed to create file: %w", err)
    }
    defer file.Close()
    // 设置文件权限
    if err := os.Chmod(path, 0644); err != nil {
        log.Printf("WARN: failed to set file permissions: %v", err)
    }
    ```

- 配置seccomp配置文件限制系统调用，禁用危险系统调用（如`mount`、`unshare`、`pivot_root`），示例：
  ```json
  {
    "defaultAction": "SCMP_ACT_ERRNO",
    "syscalls": [
      {
        "names": ["mount", "unshare", "pivot_root"],
        "action": "SCMP_ACT_KILL"
      }
    ]
  }
  ```

- 生产环境启用AppArmor或SELinux强制访问控制，通过 profiles 限制容器对宿主机资源的访问权限。

- 配置只读根文件系统（`--read-only`），防止容器在运行过程中写入根目录，提升安全性。

### 8.2 容器优化

- 镜像分层优化，将频繁变动的文件（应用代码）放在镜像上层，减少镜像构建时间和体积。

- 使用容器日志驱动（如json-file、journald），将日志输出至标准输出（stdout/stderr），便于集中收集和分析，禁止日志写入容器内部存储。

## 九、容器监控与日志规范

### 9.1 监控指标采集

- **基础监控指标**：CPU使用率、内存占用、磁盘I/O、网络流量、容器重启次数、容器状态。
- **应用级监控**：接口响应时间、错误率、并发连接数、队列深度、业务自定义指标。
- 建议集成Prometheus + Grafana实现监控可视化，通过cAdvisor或Docker Socket暴露指标端点。
- 配置告警规则，资源使用率超过阈值（如CPU>80%、内存>85%）时及时告警。

### 9.2 日志管理规范

- 应用日志统一输出至stderr，由容器引擎接管日志收集至stdout，禁止日志写入容器内部存储层。
- 配置日志驱动（如json-file、journald、syslog），生产环境建议使用集中式日志系统（如ELK、Loki）。
- 配置日志轮转策略，单个日志文件建议不超过10MB，保留最近7-30天日志，示例：
  ```yaml
  logging:
    driver: json-file
    options:
      max-size: "10m"
      max-file: "3"
  ```

- 敏感信息（密码、Token、密钥等）禁止写入日志，需在应用层实现日志脱敏。

- 日志格式统一采用结构化格式（JSON），便于解析和分析，包含时间戳、日志级别、请求ID、用户ID等字段。

## 十、CI/CD容器集成规范

### 10.1 镜像构建流程

- 镜像构建触发条件：代码提交、版本标签创建、定时任务、手动触发。
- 构建过程流水线：代码扫描 → 单元测试 → 安全扫描（Trivy）→ 镜像构建 → 多架构构建 → 推送到镜像仓库。
- 镜像版本号规范：采用语义化版本（SemVer）或Git提交哈希，生产镜像使用固定标签，禁止使用latest标签。

### 10.2 安全扫描集成

- 镜像推送到仓库前必须通过安全扫描（Trivy、Clair、Snyk）。
- 漏洞分级处理：
  - **严重（Critical）**：禁止推送至任何仓库
  - **高危（High）**：需人工确认后放行生产环境
  - **中危（Medium/Low）**：记录并定期修复
- 建立镜像签名机制，部署时使用cosign或notary验证镜像完整性。

### 10.3 部署策略

- 生产环境采用蓝绿部署或滚动更新策略，确保服务零宕机：
  ```yaml
  update_config:
    parallelism: 1
    delay: 10s
    strategy: rolling
  ```

- 保留最近3个历史版本，便于快速回滚，配置回滚策略：
  ```yaml
  rollback_config:
    parallelism: 1
    delay: 10s
  ```

- 部署前自动执行健康检查，检查通过后再切换流量，支持金丝雀发布逐步验证。

## 十一、命令与脚本规范

### 11.1 Docker Compose 命令兼容性

- **命令格式兼容**：Docker Compose 存在两种命令格式：
  - 旧版本：`docker-compose`（连字符格式，独立安装）
  - 新版本：`docker compose`（空格格式，Docker CLI插件）
  
- **脚本实现要求**：所有脚本应同时支持两种格式，优先使用新格式，失败时回退到旧格式：
  ```bash
  # Shell脚本示例
  docker compose -f docker-compose.yml up -d 2>/dev/null || docker-compose -f docker-compose.yml up -d
  
  # Windows批处理示例
  docker compose -f %COMPOSE_FILE% up -d 2>nul || docker-compose -f %COMPOSE_FILE% up -d
  ```

- **检测逻辑**：环境检测脚本应同时检测两种命令格式：
  ```bash
  if command -v docker-compose &> /dev/null || docker compose version &> /dev/null; then
      # Docker Compose可用
  fi
  ```

### 11.2 脚本命令检查规范

- **命令存在性检查**：所有脚本在使用命令前应检查命令是否存在：
  ```bash
  if command -v <command> &> /dev/null; then
      # 使用命令
  else
      # 处理命令不存在的情况
  fi
  ```

- **错误处理**：脚本应正确处理命令执行失败的情况：
  ```bash
  if ! command_execution; then
      echo "错误：命令执行失败"
      exit 1
  fi
  ```

- **变量检查**：使用变量前应检查变量是否为空：
  ```bash
  if [ -z "$VARIABLE" ]; then
      VARIABLE="default_value"
  fi
  ```

### 11.3 拼写检查规范

- **工具配置**：项目应配置拼写检查工具（如cspell），配置文件为`cspell.json`。

- **检查范围**：拼写检查应覆盖：
  - 所有脚本文件（.sh、.bat、.ps1）
  - 配置文件（.yaml、.yml、.json）
  - 文档文件（.md）
  - 代码注释

- **自定义词汇**：项目特定术语、技术名词、命令名称应添加到拼写检查白名单：
  ```json
  {
    "words": [
      "docker-compose",
      "dockerfile",
      "golangci-lint",
      "pg_isready",
      "redis-cli"
    ]
  }
  ```

### 11.4 脚本语法检查

- **Shell脚本**：使用`shellcheck`进行语法检查：
  ```bash
  shellcheck scripts/*.sh
  ```

- **批处理脚本**：Windows批处理脚本应遵循标准语法，避免使用已弃用的命令。

- **PowerShell脚本**：使用`PSScriptAnalyzer`进行语法检查：
  ```powershell
  Invoke-ScriptAnalyzer -Path scripts/*.ps1
  ```

### 11.5 命令参数规范

- **参数顺序**：命令参数应遵循标准顺序：命令 [选项] [参数]
  ```bash
  # 正确
  docker compose -f docker-compose.yml up -d
  
  # 错误
  docker compose up -d -f docker-compose.yml
  ```

- **参数引用**：包含空格或特殊字符的参数应使用引号：
  ```bash
  docker run -v "/path with spaces:/app" myapp:latest
  ```

- **环境变量**：敏感参数应通过环境变量传递，避免硬编码：
  ```bash
  docker run -e DB_PASSWORD="${DB_PASSWORD}" myapp:latest
  ```

## 十二、附则

- 本规范为个人容器开发通用标准，可根据具体项目技术栈（前端、后端、移动端）补充专项配置条款。

- 规范修订需记录版本变更日志，保持与个人开发实践同步更新，确保适配新技术、新场景。

- 本规范自制定之日起生效，所有个人容器化项目需遵循本规范实施。

## 附录：快速参考表

|| 类别 | 关键要点 | 最佳实践 |
||------|---------|---------|
|| **镜像选型** | 轻量官方镜像 + 允许latest | 可使用`latest`，但需记录digest并具备扫描/回滚/验证流程 |
|| **Dockerfile** | 多阶段构建 + 非root用户 | 分离构建与运行阶段，创建专用运行用户 |
|| **资源限制** | CPU用m单位，内存用Mi/Gi单位 | 配置requests和limits，如`memory: 128Mi`、`cpus: '0.5'` |
|| **环境变量** | 前缀命名 + 敏感信息加密 | `APP_DB_HOST`，敏感信息使用Secrets机制 |
|| **安全** | 禁用特权模式 + 最小权限原则 | `--cap-add`添加必要能力，非root用户运行 |
|| **网络** | 自定义Bridge + 网络隔离 | 自定义网络，服务发现通过服务名 |
|| **数据持久化** | Volume挂载 + 定期备份 | 命名Volume，敏感配置只读挂载 |
|| **日志** | stdout输出 + 日志轮转 | JSON格式，敏感信息脱敏 |
|| **监控** | Prometheus指标 + 告警配置 | 基础资源监控 + 应用业务指标 |
|| **Compose** | 文件结构化 + 依赖管理 | 使用x-扩展字段，`depends_on`健康检查 |
|| **调试** | 日志查看 + exec进入容器 | `docker logs -f`，`docker exec -it` |
|| **Windows容器** | OS版本指定 + 路径格式 | 明确ltsc2022等版本，使用Windows路径 |
|| **12-Factor** | 无状态 + 配置分离 | 环境变量注入，stdout日志，进程可处置 |

## 版本历史

|| 版本 | 日期 | 变更内容 |
||------|------|---------|
|| v1.0 | 2026-01-30 | 初始版本发布 |
|| v1.1 | 2026-01-30 | 修正章节编号，新增网络配置、数据持久化、监控日志、CI/CD章节，添加快速参考表 |
|| v1.2 | 2026-01-30 | 新增Docker Compose最佳实践、容器调试与排障指南、Windows容器特定配置、12-Factor应用容器化规范章节 |
|| v1.3 | 2026-01-30 | 新增命令与脚本规范章节，包含Docker Compose命令兼容性、脚本命令检查、拼写检查、语法检查等规范 |
|| v1.4 | 2026-02-02 | 调整镜像版本策略：允许使用latest（含生产），并补充digest记录、扫描、回滚与验证要求 |
|| v1.5 | 2026-02-02 | 新增单镜像模式（All-in-One）规范：用于离线/单机环境，要求入口脚本统一启动依赖并明确生产限制 |
|| v1.6 | 2026-02-02 | 明确容器内环境自动检测与默认值注入规范，补充单镜像模式下内置数据库/Redis的本地回退与优先级要求 |
|| v1.7 | 2026-02-02 | 引入“全局配置中心（强制）”概念，统一前端/后端/数据库/环境/接口等配置为单一配置源，要求通过配置中心派生各端配置 |

> （注：文档部分内容可能由 AI 生成）
