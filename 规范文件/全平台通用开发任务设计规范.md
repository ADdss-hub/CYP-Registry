# 全平台通用开发任务设计规范

||**作者**：CYP | **联系方式**：nasDSSCYP@outlook.com |
||---|---|
|| **版本**：v1.0.0 | **最后更新**：2026年2月24日 |

---

## 文档修订记录

|| 版本 | 日期 | 修订内容 | 修订人 |
||------|------|----------|--------|
|| v1.0.0 | 2026年2月24日 | 初始版本：定义全平台通用开发任务的设计规范与交付要求 | CYP |

---

提示：本规范为通用基础框架，请根据具体项目的技术栈、业务场景、团队规模适配调整，核心约束条款不得随意违背，特别是“仅使用免费开源资源”“禁止在开发环境执行测试”等强约束要求。

## 目录

- [一、总则](#一总则)
  - [1.1 文档目的](#11-文档目的)
  - [1.2 适用范围](#12-适用范围)
  - [1.3 核心约束](#13-核心约束)
- [二、文档管理规范](#二文档管理规范)
- [三、文档生命周期管理](#三文档生命周期管理)
- [四、项目结构规范](#四项目结构规范)
- [五、代码目录规范](#五代码目录规范)
- [六、API 服务规范](#六api-服务规范)
- [七、测试与生产环境规范](#七测试与生产环境规范)
- [八、日志管理规范](#八日志管理规范)
- [九、安全开发规范](#九安全开发规范)
- [十、错误处理与异常管理规范](#十错误处理与异常管理规范)
- [十一、依赖库管理规范](#十一依赖库管理规范)
- [十二、Git协作与代码审查规范](#十二git协作与代码审查规范)
- [十三、发布与部署流程规范](#十三发布与部署流程规范)
- [十四、性能优化规范](#十三性能优化规范)
- [十五、前后端联调规范](#十四前后端联调规范)
- [十六、附录](#十五附录)

## 使用说明

### 一、适配核心原则

1. 场景适配：在使用本规范前，应根据项目规模（单人/小团队）、技术栈（前端框架、后端语言、数据库类型）以及交付周期，对部分章节进行“必选/可选”划分，避免在极简项目中引入过重流程。
2. 一致性优先：同一项目内所有开发任务（无论前端/后端/脚本）必须使用统一的任务设计单模板、目录结构与命名规范，禁止出现“每个模块一套写法”的情况。
3. 强约束优先：涉及生产安全、合规、数据风险的条款（如只用免费开源资源、禁止在开发环境执行测试）不得随意弱化或绕过，确需例外时必须在任务设计单中单独说明并评估风险。

### 二、落地与维护方式

1. 首次落地：在项目初始化阶段，先根据本规范确定根目录结构、docs 文档分类、任务设计单模板位置，以及与 Git 规范/环境配置规范的联动点。
2. 规则固化：将本规范关键约束转化为工具配置或脚本（如 lint、目录检查、命名检查），通过 Git Hooks 或 CI 在提交/合并阶段进行自动校验。
3. 文档同步：每次项目结构、任务拆解流程或测试策略发生调整时，需同步更新本规范的版本号与修订记录，并在 README/开发手册中给出简要指引链接。

### 三、自查与培训

1. 自查频率：建议每个迭代结束后，由责任人对照自查清单逐项检查是否存在“无设计先编码”“文档未同步更新”等违规情况。
2. 新人培训：新加入项目的开发者在接任务前，应阅读本规范并通过一份示例任务设计单演练（从需求拆解到测试验收），确保理解整体流程。
3. 工具辅助：推荐使用免费的文档/看板工具（如 GitHub Projects、Markdown 文档 + Issue 追踪）承载任务设计单与状态，保证信息可追溯。

#### 规范自查清单（开发任务设计）

为便于快速核验是否按本规范执行开发任务，建议在附录中维护统一的《开发任务设计自查清单》，按项目实际适配后逐项勾选确认。

# 一、总则

## 1.1 文档目的

为保障全平台（网页端、管理端等）开发任务的规范性、可维护性、高效性，统一开发标准与流程，降低协作成本，确保最终产出符合生产环境要求，特制定本规范。

## 1.2 适用范围

本规范适用于所有全平台开发任务，涵盖需求拆解、目录设计、编码实现、API 开发、测试上线等全流程，所有参与项目开发的人员必须严格遵循。

## 1.3 核心约束

- 技术选型约束：开发过程中仅允许使用免费开源接口、库及工具，禁止引入商业付费组件或存在版权争议的资源。

- 环境测试约束：所有开发工作以生产环境标准为核心，开发环境仅用于功能编码实现，禁止在开发环境执行任何测试操作，测试工作统一在生产环境开展（需做好数据隔离与备份措施）。

- 交付质量约束：最终产出需满足生产环境稳定性、安全性要求，可直接部署上线并承受实际业务压力。

# 二、文档管理规范

## 2.1 目录与模块原则

严格遵循"单一、集中、统一、自动"原则，确保项目结构清晰、可追溯、易扩展。

- 单一性：每个功能模块对应独立目录，模块内仅存放与本功能直接相关的代码、配置文件，禁止跨模块混放资源。

- 集中性：公共资源（通用工具类、全局配置、公共组件）集中存放于统一公共目录，避免重复开发与分散管理。

- 统一性：目录命名、文件命名、代码风格、配置格式严格遵循本规范统一标准，全团队保持一致。

- 自动化：借助免费工具（如 ESLint、Prettier、Git Hooks）实现目录结构校验、代码格式自动格式化、提交规范自动校验，减少人工干预。

# 三、文档生命周期管理

## 3.1 核心原则

遵循"完整、准确、可追溯、安全统一"原则，覆盖文档全生命周期管理，确保所有项目文档与生产环境需求一致，为开发、测试、运维提供可靠依据。文档管理需与代码开发同步推进，禁止出现"代码与文档脱节"情况。

## 3.2 文档分类与存放

所有文档统一存放于项目根目录`docs`文件夹，按"模块+文档类型"双重维度分类归档，新增子目录需同步更新项目根目录README.md的文档结构说明。具体分类及存放路径如下：

- 需求类文档：存放于`docs/requirements`，含需求规格说明书、需求变更单、用户故事等，按功能模块拆分子目录（如`docs/requirements/user_management`）。

- 设计类文档：存放于`docs/design`，含技术架构设计、数据库设计、UI原型、组件设计等，核心设计文档需标注与生产环境适配的技术参数。

- 接口类文档：存放于`docs/api`，含接口规格说明书、请求响应示例、异常处理说明，需与API开发同步更新，采用Swagger/Apifox免费版生成可交互文档。

- 测试类文档：存放于`docs/test`，含测试方案、测试用例、生产环境测试报告、问题清单及闭环记录，需详细标注测试范围与生产数据隔离措施。

- 运维类文档：存放于`docs/ops`，含部署流程、环境配置、监控方案、故障排查手册，需适配生产环境部署架构。

- 规范类文档：存放于`docs/spec`，含本开发规范、编码规范、命名规范等，更新后需同步通知所有团队成员。

## 3.3 文档命名与编号

### 3.3.1 命名规则

统一采用"模块标识_文档类型_文档名称_版本号.md"格式命名，模块标识采用小写下划线（snake_case），文档类型用缩写（需求：REQ、设计：DES、接口：API、测试：TST、运维：OPS、规范：SPC），示例：`user_management_REQ_用户登录需求_V1.0.md`。

### 3.3.2 编号规则

为每份文档分配唯一编号，格式为"YYYY-模块代码-文档类型-序号"，确保可追溯。其中：YYYY为年份，模块代码为2位缩写（用户管理：UM、数据分析：DA），文档类型为1位字母（同命名缩写首字母），序号为3位自增数。示例：`2026-UM-R-001`（2026年用户管理模块第1份需求文档）。

## 3.4 文档编制与审核

- 编制要求：内容需准确、清晰、完整，符合生产环境标准，避免模糊表述；技术文档需标注核心参数、兼容范围，与选用的免费库/接口适配；统一采用Markdown格式编写，图表嵌入文档对应位置，附件存放于对应文档目录的`attachments`子文件夹。

- 审核流程：编制完成后由模块负责人审核（核对内容准确性、适配性），核心文档（架构设计、接口规范）需经技术负责人批准，审核通过后方可归档；审核意见需书面记录于文档末尾"审核备注"栏，未通过文档需修改后重新提交审核。

## 3.5 版本控制

- 版本号规则：采用"主版本.次版本.修订号"格式（如V1.0.0），主版本变更为重大迭代（核心逻辑调整），次版本变更为功能补充，修订号变更为文字纠错、细节优化。

- 版本追溯：文档每更新一次需同步升级版本号，在文档开头标注"版本历史"，记录版本号、更新时间、更新人、更新内容，示例：

```plain text

### 版本历史
| 版本号 | 更新时间   | 更新人 | 更新内容                     |
|--------|------------|--------|------------------------------|
| V1.0.0 | 2026-XX-XX | CYP    | 初始编制用户登录需求文档     |
| V1.0.1 | 2026-XX-XX | CYP    | 修正登录时效参数表述         |
```

- 版本存储：通过Git进行版本控制，文档更新需随代码提交同步推送，提交信息需标注文档编号及版本变更原因，禁止私自修改已归档文档。

## 3.6 存储与备份

- 电子存储：文档以Markdown格式为主，核心设计图、原型图采用通用格式（PNG、PDF），确保跨设备可打开；借助Git仓库与云盘（免费版，如阿里云盘、百度网盘）双重存储，云盘按项目名称创建专属文件夹，定期（每周）手动备份或通过脚本自动备份。

- 权限管理：Git仓库与云盘仅对项目成员开放权限，明确"编制者可修改、审核者可审批、普通成员可查看"，禁止向外部泄露生产环境相关文档（如部署配置、接口密钥说明）。

## 3.7 变更与归档

- 变更管理：文档需变更时，由编制者提交变更申请（注明变更原因、影响范围），经原审核人审核通过后实施变更，变更后同步更新版本号及历史记录，旧版本文档保留归档，禁止删除。

- 归档管理：项目迭代完成后，将对应版本文档归档至`docs/archive/YYYYMM`目录（按年月分类），归档文档标注"归档日期"及"对应生产版本"，便于后续追溯。

# 四、项目结构规范

## 4.1 根目录结构

项目根目录仅保留核心目录与必要文件，结构如下（以全栈项目为例）：

```plain text

project-root/
├── docs/          # 统一文档存放目录
│   ├── requirements/  # 需求文档
│   ├── design/        # 技术设计文档
│   ├── api/           # 接口文档
│   ├── test/          # 测试报告（生产环境测试生成）
│   ├── ops/           # 运维类文档
│   └── spec/          # 规范类文档
├── src/           # 核心代码目录
│   ├── common/       # 公共模块（通用工具、公共组件、全局配置）
│   │   ├── utils/    # 工具函数
│   │   ├── components/  # 公共组件
│   │   └── config/   # 全局配置（含API端口配置）
│   ├── modules/      # 功能模块目录（按功能拆分）
│   │   ├── module1/  # 功能模块1（例：用户管理）
│   │   │   ├── controller/  # 控制层（后端）/ 页面组件（前端）
│   │   │   ├── service/     # 业务逻辑层
│   │   │   ├── model/       # 数据模型层
│   │   │   └── index.js     # 模块入口文件
│   │   └── module2/  # 功能模块2（依此类推）
│   ├── api/          # API请求封装目录（前端）/ 接口路由目录（后端）
│   └── main.js       # 项目入口文件
├── scripts/       # 自动化脚本目录（构建、部署、格式化脚本）
├── .env           # 环境变量配置（生产环境为主）
├── .eslintrc.js   # 代码校验配置
├── .prettierrc    # 代码格式化配置
└── README.md      # 项目说明文档
```

## 4.2 目录命名规范

- 目录名称统一采用小写字母+下划线（snake_case）命名，禁止使用大写字母、中文、特殊字符。

- 功能模块目录名称需体现模块核心职责，如`user_management`（用户管理）、`data_analysis`（数据分析）。

- 禁止创建层级过深的目录（建议不超过4级），避免代码检索与维护困难。

# 五、代码目录规范

## 5.1 文件编码约束

- 单个代码文件行数严格限制在 500 行以内（含注释），超过 500 行需拆分为多个子文件，按功能拆分至对应子目录，确保文件轻量化、职责单一。

- 文件命名统一采用小写字母+下划线（后端）、首字母大写驼峰（PascalCase，前端组件），如 `user_service.js`（后端）、`UserList.vue`（前端组件）。

## 5.2 代码风格规范

- 遵循对应语言的通用编码规范（如 JavaScript 遵循 Airbnb 规范），借助 ESLint、Prettier 等免费工具自动校验与格式化。

- 代码注释完整：函数/类需标注用途、参数、返回值；复杂逻辑需添加行内注释，确保他人可快速理解。

- 禁止冗余代码：废弃代码、调试代码（console.log 等）需及时删除，避免占用资源与干扰生产环境。

## 5.3 模块开发规范

- 每个功能模块需具备独立入口文件（index.js），对外暴露统一接口，禁止直接引用模块内非入口文件。

- 模块间通信通过公共接口或全局状态管理实现，禁止跨模块直接操作对方内部资源，降低耦合度。

- 公共模块（common）仅存放全项目通用资源，禁止将模块专属逻辑放入公共模块。

## 5.4 编码错误与乱码防控规范

编码错误、乱码会直接导致生产环境功能异常、数据错乱，需从编码格式、错误排查、校验机制三方面严格管控，杜绝此类问题。

- 统一编码格式：所有代码文件、配置文件、静态资源文件（如文本、JSON）强制采用 UTF-8 编码格式，禁止使用 GBK、GB2312 等其他编码。前端 HTML 页面需在 meta 标签明确指定编码（`<meta charset="UTF-8">`），后端接口响应头需统一设置编码格式（如 `Content-Type: application/json; charset=UTF-8`），数据库连接也需指定 UTF-8 编码，确保数据传输与存储无乱码。

- 禁止编码错误：开发过程中需严格规避语法错误、语义错误、变量未定义、函数调用异常等编码错误，借助编译器（如 VS Code、IntelliJ IDEA）实时校验功能、ESLint 等免费静态检查工具，提前排查潜在错误。提交代码前必须本地运行验证，确保无编译报错、运行时错误。

- 特殊字符处理：针对中文、特殊符号（如空格、标点、转义字符），需规范处理避免乱码。前端输入框需做字符过滤与转义，后端接收参数后需进行编码校验与清洗，禁止直接存储或渲染未经处理的特殊字符；文件命名、路径配置中禁止使用中文及特殊符号，仅允许字母、数字、下划线、连字符。

- 自动化校验与兜底：将编码格式校验、语法错误检查纳入 Git Hooks 与 CI 流程（使用免费工具如 Husky、GitHub Actions），提交代码时自动拦截编码异常、语法错误文件，禁止合并至主分支。生产环境需添加错误捕获日志（如前端 try-catch、后端异常拦截），记录编码相关异常信息，便于快速排查定位。

# 六、API 服务规范

## 6.1 端口统一配置

所有 API 服务统一使用单一端口提供服务，端口号配置于全局配置文件（src/common/config/api.js），禁止在代码中硬编码端口号。示例：

```javascript

// src/common/config/api.js
module.exports = {
  baseUrl: 'http://xxx.xxx.xxx.xxx',
  port: 8080, // 统一API端口
  timeout: 5000
};
```

端口选择需避开常用占用端口（如 80、443、3306 等），确保生产环境端口可正常暴露与访问。

## 6.2 接口开发规范

- 接口设计遵循 RESTful 风格，统一接口命名格式、请求方式、响应格式。

- 接口文档统一使用免费工具（如 Swagger、Apifox 免费版）生成，存放于 docs/api 目录，随接口开发同步更新。

- 接口依赖的第三方服务需选用免费接口，优先选择稳定性高、文档完善的开源接口，避免依赖付费接口导致生产环境风险。

## 6.3 统一响应格式

所有接口返回统一采用以下 JSON 格式，便于前端统一处理：

```json
{
  "code": 20000,
  "message": "操作成功",
  "data": {},
  "timestamp": 1704067200000
}
```

- `code`：状态码（20000成功，其他为业务错误码）
- `message`：提示信息
- `data`：响应数据
- `timestamp`：响应时间戳

## 6.4 错误码规范

- 系统级错误：10001-19999（如参数校验失败、权限不足）
- 业务级错误：20001-29999（如用户不存在、订单已关闭）
- 第三方服务错误：30001-39999（如第三方API调用失败）

# 七、测试与生产环境规范

## 7.1 环境约束

- 开发环境仅用于代码编写、本地调试（无测试操作），禁止在开发环境模拟生产数据、执行测试用例。

- 所有测试工作（单元测试、集成测试、功能测试、压力测试）均在生产环境开展，测试前需做好数据备份、流量隔离，避免影响生产业务正常运行。

- 测试环境与生产环境需保持配置一致性，测试环境作为生产环境的"预演"，两者的差异需记录在案并经团队评审确认。

## 7.2 生产环境测试要求

- 测试前需制定详细测试方案，明确测试范围、测试用例、预期结果，方案存放于 docs/test 目录。

- 测试过程中需记录测试日志、问题清单，测试完成后生成测试报告，同步更新至 docs/test 目录，作为上线依据。

- 测试发现的问题需在开发环境修复后，重新部署至生产环境进行回归测试，直至所有问题闭环。

- 测试用例执行完毕后，需在测试报告中标注"通过率"、"阻塞问题数"、"遗留问题清单及处理计划"。

## 7.3 测试用例模板

测试用例需采用统一模板编写，确保可追溯、可复用：

```markdown
### 用例编号：[模块名]_TC_[序号]
### 用例名称：[简要描述测试目标]
### 前置条件：[执行用例前需满足的环境状态]
### 测试步骤：
1. [步骤1]
2. [步骤2]
3. [步骤3]
### 预期结果：[步骤对应的期望输出]
### 优先级：[P0/P1/P2]
### 执行人：[测试执行者]
### 执行时间：[YYYY-MM-DD]
### 测试数据：[使用的测试数据]
### 备注：[特殊说明]
```

## 7.4 自动化测试要求

- 核心业务逻辑（用户登录、订单处理、支付流程）必须编写自动化测试用例，存放于 `tests/` 目录。

- 自动化测试需覆盖：单元测试（函数/方法级）、集成测试（模块间交互）、端到端测试（关键用户流程）。

- 自动化测试用例需纳入 CI/CD 流程，每次代码提交自动触发，执行失败则阻断合并。

- 自动化测试覆盖率要求：核心模块不低于 80%，全项目不低于 60%。

- 自动化测试工具选型（免费开源）：
  - 前端：Jest、Cypress、Playwright
  - 后端：Jest、Pytest、Mocha
  - API 测试：Postman（免费版）、Supertest

## 7.5 测试数据管理

- 测试数据需与生产数据严格隔离，禁止直接使用生产真实数据（需脱敏或使用虚拟数据）。

- 测试数据需版本化管理，每次测试前确保使用最新版本测试数据集。

- 大规模测试数据生成可使用脚本自动化，脚本存放于 `scripts/test-data/` 目录。

- 测试数据使用后需及时清理，避免占用生产环境资源。

## 7.3 上线前检查清单

功能上线前需完成以下检查：

- [ ] 代码已通过 ESLint/Prettier 校验
- [ ] 无控制台错误或警告
- [ ] 接口文档已更新并同步
- [ ] 测试用例全部通过
- [ ] 回滚方案已准备就绪
- [ ] 监控告警已配置
- [ ] 运维文档已更新

# 八、日志管理规范

## 8.1 日志级别定义

- `ERROR`：错误日志（影响功能正常运行，需要立即处理）
- `WARN`：警告日志（潜在问题，不影响当前功能）
- `INFO`：信息日志（关键业务流程节点）
- `DEBUG`：调试日志（开发调试用，生产环境禁止输出）

## 8.2 日志记录规范

- 日志需包含时间戳、模块名称、日志级别、关键上下文信息

- 禁止在日志中记录敏感信息（密码、密钥、用户隐私数据）

- 生产环境日志按日期切分，保留周期不少于30天

- 日志文件命名格式：`[应用名]_[日志级别]_[YYYY-MM-DD].log`

## 8.3 日志格式示例

```plain text
[2026-01-30 10:30:45] [ERROR] [user_service] [abc123] 用户登录失败：密码错误
```

- 时间戳：YYYY-MM-DD HH:mm:ss
- 级别：ERROR/WARN/INFO/DEBUG
- 模块：产生日志的模块名称
- 请求ID：trace_id 用于链路追踪
- 内容：日志描述信息

## 8.4 日志收集与管理

### 8.4.1 日志收集工具

生产环境需配置集中式日志收集系统，便于查询与分析（免费开源方案）：

| 工具 | 用途 | 部署方式 |
|------|------|----------|
| ELK Stack（Elasticsearch + Logstash + Kibana） | 日志收集、存储、搜索、可视化 | Docker容器化部署 |
| Loki + Grafana | 轻量级日志系统 | Docker部署 |
| Filebeat | 日志采集 | 部署于应用服务器 |
| Graylog | 日志管理平台 | Docker部署 |

### 8.4.2 日志存储要求

- 日志文件统一存放于 `/var/log/[应用名]/` 目录
- 单个日志文件大小超过 100MB 时自动切割
- 日志文件权限设置为 640（所有者读写，同组读，其他无）
- 定期将日志文件归档至冷存储（超过30天的日志）

### 8.4.3 日志分析指导

- 关键指标监控：错误率（ERROR日志占比）、响应时间、接口调用频次
- 异常模式识别：同一错误频繁出现、特定时间段的异常峰值
- 日志告警配置：错误率超过阈值时自动发送告警通知（邮件/钉钉/企业微信）
- 日志查询规范：禁止在生产环境直接查询日志，需通过日志平台界面操作

## 8.5 链路追踪规范

- 分布式系统需实现全链路追踪，为每个请求分配唯一 trace_id

- trace_id 在请求入口生成，贯穿整个调用链，直至响应返回

- trace_id 需传递至所有子服务、日志、数据库查询

- 链路追踪工具推荐：Jaeger（免费开源）、Zipkin

- 日志输出时必须包含 trace_id，便于关联分析

# 九、安全开发规范

## 9.1 输入校验

- 所有外部输入必须进行参数校验，包括类型、长度、格式等

- 防止 SQL 注入：禁止拼接 SQL，使用参数化查询

- 防止 XSS 攻击：对用户输入进行转义或过滤

- 防止 CSRF 攻击：使用 Token 验证或 SameSite Cookie

- 文件上传安全：限制文件类型、大小，存储时重命名文件，禁止执行上传目录中的文件

## 9.2 敏感数据处理

- 密码、密钥等敏感数据必须加密存储（如 bcrypt、AES）

- 接口响应禁止返回敏感信息明文

- 日志中禁止出现完整敏感数据

- API 密钥、数据库密码等需通过环境变量或密钥管理服务注入，禁止硬编码

- 敏感数据传输必须使用 HTTPS/TLS 加密

## 9.3 权限控制

- 接口需进行身份认证和权限校验

- 遵循最小权限原则，仅授予必要权限

- 关键操作需记录操作日志

- Token 设置合理的过期时间，敏感操作需二次验证

## 9.4 安全场景与应对策略

| 安全场景 | 风险描述 | 应对措施 |
|----------|----------|----------|
| 暴力破解 | 攻击者反复尝试登录密码 | 登录失败次数限制、验证码、IP封禁 |
| 接口越权 | 用户访问未授权的他人数据 | 接口校验数据归属关系 |
| 重放攻击 | 请求被重复发送 | 添加时间戳、nonce 随机数 |
| 文件包含 | 恶意文件被包含执行 | 禁止用户输入文件路径、使用白名单 |
| 拒绝服务 | 请求耗尽系统资源 | 限流、熔断、服务降级 |
| 信息泄露 | 错误信息暴露系统内部细节 | 统一错误返回格式，生产环境关闭详细错误 |

## 9.5 安全编码 checklist

- [ ] 敏感配置信息不提交至 Git 仓库
- [ ] 第三方依赖库定期进行安全扫描（如 Snyk、npm audit）
- [ ] 生产环境关闭调试模式、详细错误输出
- [ ] 数据库连接使用最小权限账户
- [ ] API 接口添加速率限制
- [ ] 关键操作（登录、支付、权限变更）记录审计日志
- [ ] 定期进行安全漏洞扫描与渗透测试

# 十、错误处理与异常管理规范

## 10.1 异常分类

| 异常类型 | 说明 | 处理策略 |
|----------|------|----------|
| 系统异常 | 服务器错误、网络异常、数据库连接失败等 | 降级处理、记录错误日志、告警通知 |
| 业务异常 | 业务逻辑校验失败（如余额不足、权限不够等） | 返回友好提示、记录业务日志 |
| 参数异常 | 请求参数校验失败（类型、格式、范围） | 返回具体错误信息、引导用户修正 |
| 第三方异常 | 外部服务调用失败（API、超时） | 重试机制、降级处理、记录异常详情 |

## 10.2 异常处理原则

- **统一异常捕获**：所有接口入口处设置全局异常处理器，统一捕获并处理未预期异常

- **异常信息脱敏**：面向用户的错误信息需脱敏，禁止暴露系统内部细节（如堆栈信息、文件路径）

- **异常日志完整**：记录异常的完整上下文，包括请求参数、用户信息、trace_id、堆栈信息

- **异常分级响应**：根据异常严重程度采取不同响应策略（重试、降级、告警、中断）

## 10.3 前端错误处理规范

- **请求拦截**：封装统一的 HTTP 请求拦截器，处理 4xx/5xx 错误

- **错误展示**：用户可见错误信息需友好、明确，避免直接展示技术错误

- **错误重试**：网络请求失败需有自动重试机制（最多3次，间隔递增）

- **状态管理**：将错误状态纳入全局状态管理，统一展示错误提示组件

- **错误边界**：React/Vue 应用需设置 Error Boundary，防止单个组件错误导致整个页面崩溃

### 10.3.1 全局错误收集器

所有前端项目必须实现全局错误和成功收集器，用于统一收集、管理和分析应用运行过程中的所有错误和成功事件。

#### 10.3.1.1 收集器功能要求

- **错误收集**：收集所有类型的错误，包括：
  - Vue/React 组件错误
  - JavaScript 运行时错误
  - 未处理的 Promise 拒绝
  - 资源加载错误（图片、CSS、JS等）
  - API 请求错误（网络错误、HTTP错误、业务错误）

- **成功收集**：收集所有成功的操作，包括：
  - API 请求成功
  - 用户操作成功
  - 关键业务流程成功

- **统计信息**：提供实时统计信息，包括：
  - 总记录数
  - 错误数量
  - 成功数量
  - 错误率（错误数/总记录数）

#### 10.3.1.2 实现规范

- **位置**：错误收集器应作为独立的 composable/hook，存放于 `src/composables/useErrorCollector.ts`（Vue）或 `src/hooks/useErrorCollector.ts`（React）

- **数据结构**：每条记录应包含以下字段：
  ```typescript
  interface ErrorRecord {
    id: string                    // 唯一标识
    timestamp: string             // ISO 8601 格式时间戳
    type: 'error' | 'success'     // 记录类型
    url: string                   // 请求URL或页面URL
    method: string                // HTTP方法或操作类型
    status?: number               // HTTP状态码
    message: string               // 错误或成功消息
    error?: any                   // 错误对象（仅错误类型）
    stack?: string                // 错误堆栈（仅错误类型）
    component?: string            // 组件名称（仅Vue/React错误）
    info?: string                 // 额外信息
  }
  ```

- **存储限制**：最多保存 1000 条记录，超出后自动删除最旧的记录

- **集成位置**：
  - 在应用入口文件（`main.ts` 或 `main.js`）中初始化全局错误收集器
  - 在 API 拦截器中集成，自动收集所有 API 请求的成功和失败
  - 在全局错误处理器中集成，自动收集所有运行时错误

#### 10.3.1.3 使用示例

```typescript
// 在 API 拦截器中
apiClient.interceptors.response.use(
  (response) => {
    errorCollector.recordSuccess({
      url: response.config.url,
      method: response.config.method,
      status: response.status,
      message: '请求成功',
    })
    return response
  },
  (error) => {
    errorCollector.recordError({
      url: error.config?.url || 'unknown',
      method: error.config?.method || 'unknown',
      status: error.response?.status,
      message: error.message,
      error: error,
      stack: error.stack,
    })
    return Promise.reject(error)
  }
)

// 在 Vue 全局错误处理器中
app.config.errorHandler = (err, instance, info) => {
  errorCollector.recordError({
    url: window.location.href,
    method: 'VUE_COMPONENT',
    message: err.message,
    error: err,
    stack: err.stack,
    component: instance?.$?.type?.name,
    info: typeof info === 'string' ? info : JSON.stringify(info),
  })
}
```

#### 10.3.1.4 导出功能

错误收集器应提供以下功能：

- `recordError(error)`：记录错误
- `recordSuccess(success)`：记录成功
- `getRecentErrors(limit)`：获取最近的错误记录
- `getRecentSuccesses(limit)`：获取最近的成功记录
- `getAllRecords()`：获取所有记录
- `clearRecords()`：清空所有记录
- `exportRecords()`：导出记录为JSON格式
- `stats`：计算属性/状态，提供统计信息

#### 10.3.1.5 日志输出

- **开发环境**：所有记录应输出到控制台，便于调试
- **生产环境**：仅记录到内存，不输出到控制台，避免影响性能
- **导出功能**：提供导出功能，便于问题排查和数据分析

## 10.4 后端异常处理规范

### 10.4.1 统一响应格式

所有接口返回统一采用以下 JSON 格式：

```json
{
  "code": 20000,
  "message": "操作成功",
  "data": {},
  "timestamp": 1704067200000,
  "trace_id": "abc123xyz",
  "request_id": "req_20260130_001"
}
```

### 10.4.2 业务异常类定义

```javascript
// src/common/exception/BusinessException.js
class BusinessException extends Error {
  constructor(code, message, details = null) {
    super(message);
    this.name = 'BusinessException';
    this.code = code;
    this.details = details;
    this.timestamp = Date.now();
  }
}

// 使用示例
throw new BusinessException(20001, '用户不存在', { userId: 12345 });
```

### 10.4.3 全局异常处理器

```javascript
// src/common/exception/GlobalExceptionHandler.js
function globalExceptionHandler(err, ctx) {
  // 记录完整错误日志
  logger.error({
    message: err.message,
    stack: err.stack,
    trace_id: ctx.trace_id,
    request: ctx.request,
    timestamp: Date.now()
  });

  // 根据异常类型返回对应响应
  if (err instanceof BusinessException) {
    return {
      code: err.code,
      message: err.message,
      details: err.details,
      timestamp: err.timestamp
    };
  }

  // 系统异常返回通用错误
  return {
    code: 50000,
    message: '系统繁忙，请稍后重试',
    timestamp: Date.now()
  };
}
```

## 10.5 错误码规范

| 错误码范围 | 类型 | 说明 |
|------------|------|------|
| 10001-19999 | 参数错误 | 请求参数校验失败 |
| 20001-29999 | 业务错误 | 业务逻辑校验失败 |
| 30001-39999 | 权限错误 | 认证/授权失败 |
| 40001-49999 | 资源错误 | 资源不存在、被占用 |
| 50001-59999 | 系统错误 | 服务器内部错误 |
| 60001-69999 | 第三方错误 | 外部服务调用失败 |

## 10.6 错误监控与告警

- **错误监控**：集成错误监控工具（如 Sentry、LogRocket 免费版），实时收集生产环境错误

- **告警规则**：
  - 错误率超过 1% 触发告警
  - 同一错误 5 分钟内出现 10 次以上触发告警
  - 核心接口错误立即告警

- **告警通知**：通过邮件、钉钉、企业微信等渠道实时通知

- **错误复盘**：每周汇总分析错误数据，制定优化措施

# 十、依赖库管理规范

## 10.1 依赖库选型约束

- 所有选用的库、工具、接口必须为免费开源版本，优先选择 MIT、Apache 等宽松开源协议的资源，避免版权纠纷。

- 选型时需评估资源的稳定性、更新频率、社区活跃度，避免选用无人维护、存在安全漏洞的库或工具。

- 项目依赖库需统一管理（如前端 package.json、后端 package.json），锁定版本号，避免因版本差异导致生产环境问题。

## 10.2 依赖库兼容性要求

依赖库兼容性直接影响生产环境稳定性，需从版本适配、跨环境兼容、依赖链管控三方面严格把控，杜绝兼容性故障。

- 版本兼容性管控：选用库时需明确版本兼容范围，优先选择主流稳定版本，避免使用测试版、预览版或停止维护的旧版本。对于核心依赖库，需在技术设计文档中注明兼容版本区间（如 `rich>=13,<14`），同时通过锁文件（如 package-lock.json、uv.lock）精确锁定依赖版本及依赖树，确保全环境依赖一致性。

- 跨环境与技术栈兼容：需验证依赖库与项目技术栈（如前端框架、后端运行时、数据库版本）的兼容性，前端库需适配目标浏览器版本，后端库需兼容部署环境的操作系统、运行时版本。禁止引入与现有技术栈存在冲突的库，必要时通过免费静态分析工具（如 Python 静态检测工具、ESLint 插件）提前排查兼容性问题。

- 依赖链冲突处理：定期使用免费工具（如 npm audit、depcheck）检测依赖链冲突及冗余依赖，优先选用无嵌套依赖或嵌套依赖较少的库，降低冲突风险。若出现兼容性冲突，优先更换冲突库为功能等效的兼容库，而非修改库源码，确保依赖链可维护性。

- 兼容性验证流程：新增依赖库需在生产环境隔离测试区完成兼容性验证，测试范围包括功能适配、性能影响、安全合规性，验证通过后方可纳入项目依赖。版本更新时需同步开展回归测试，确认无兼容性退化。

## 10.3 依赖管理规范

- 依赖配置文件（如 package.json、pyproject.toml）需统一存放于项目根目录，明确区分运行时依赖与开发依赖，避免开发依赖冗余打包至生产环境。

- 依赖更新需遵循"最小变更"原则，仅在修复漏洞、新增必要功能时更新版本，更新前需记录变更日志，同步更新 docs/design 目录下的依赖说明文档。

# 十一、Git协作与代码审查规范

## 11.1 分支策略

采用 Git Flow 工作流，核心分支规范如下：

| 分支名称 | 用途 | 生命周期 | 保护规则 |
|----------|------|----------|----------|
| main/prod | 生产环境代码 | 长期 | 禁止直接推送，需 PR 合并 |
| develop | 开发主分支 | 长期 | 禁止直接推送，需 PR 合并 |
| feature/* | 功能开发分支 | 短期 | 功能完成后删除 |
| release/* | 发布准备分支 | 短期 | 合并后删除 |
| hotfix/* | 紧急修复分支 | 短期 | 合并后删除 |

- **命名规范**：
  - 功能分支：`feature/[模块名]-[功能简述]`，如 `feature/user-login`
  - 发布分支：`release/[版本号]`，如 `release/v1.2.0`
  - 修复分支：`hotfix/[问题简述]`，如 `hotfix-login-error`

- **分支创建**：从 develop 创建功能分支，开发完成后合并至 develop 进行集成测试

## 11.2 提交规范

### 11.2.1 提交信息格式

```plain text
<类型>(<范围>): <描述>

[可选的正文]

[可选的脚注]
```

### 11.2.2 类型分类

| 类型 | 说明 | 示例 |
|------|------|------|
| feat | 新功能 | `feat(user): 添加用户登录功能` |
| fix | Bug 修复 | `fix(auth): 修复登录超时问题` |
| docs | 文档更新 | `docs: 更新 API 文档` |
| style | 代码格式 | `style: 格式化代码` |
| refactor | 重构代码 | `refactor(user): 重构用户模块` |
| perf | 性能优化 | `perf: 优化数据库查询` |
| test | 测试相关 | `test: 添加登录测试用例` |
| chore | 构建/工具 | `chore: 更新依赖版本` |

### 11.2.3 提交示例

```plain text
feat(user): 添加用户手机号登录功能

- 支持手机号+验证码登录
- 集成短信服务发送验证码
- 添加登录失败次数限制

Closes #123
```

## 11.3 代码审查（Code Review）规范

### 11.3.1 Pull Request 要求

- **PR 描述**：清晰描述功能/修复内容、测试结果、影响范围
- **PR 大小**：单次 PR 代码变更不超过 500 行，便于审查
- **检查项**：
  - [ ] 代码符合编码规范（ESLint/Prettier 通过）
  - [ ] 单元测试覆盖率达标
  - [ ] 无控制台错误或警告
  - [ ] 接口文档已更新
  - [ ] 必要的注释已添加
- **关联事项**：PR 需关联对应的需求/任务编号（如 `#123`）

### 11.3.2 审查原则

- **及时性**：收到审查请求后 24 小时内完成初审
- **建设性**：审查意见需具体、建设性，避免模糊表述
- **客观性**：审查代码而非人，保持礼貌和专业
- **重点明确**：优先检查逻辑正确性、安全性、性能，其次是风格规范

### 11.3.3 审查检查清单

| 检查项 | 检查内容 | 优先级 |
|--------|----------|--------|
| 逻辑正确 | 业务逻辑是否符合需求 | P0 |
| 边界处理 | 参数校验、异常处理是否完善 | P0 |
| 安全合规 | 无 SQL 注入、XSS、越权等安全风险 | P0 |
| 性能影响 | 无明显性能问题（循环、N+1查询等） | P1 |
| 代码规范 | 命名、注释、格式符合规范 | P2 |
| 可维护性 | 代码结构清晰，易于理解 | P2 |
| 测试覆盖 | 核心逻辑有对应测试用例 | P1 |
| 文档同步 | 接口文档、README 是否更新 | P2 |

### 11.3.4 审查流程

```plain text
1. 开发者完成开发，推送分支
2. 创建 Pull Request，填写描述
3. 自动检查通过（CI 流程）
4. 指定审查者（至少 1 人，核心模块需 2 人）
5. 审查者提出修改意见
6. 开发者修改并回复意见
7. 审查者 approval
8. 合并至目标分支
9. 删除源分支
```

## 11.4 Git Hooks 与 CI 配置

- **Pre-commit**：代码提交前自动执行 ESLint/Prettier 检查，不通过则禁止提交

- **Commit-msg**：校验提交信息格式，不符合规范则禁止提交

- **Pre-push**：推送前执行单元测试，测试失败则禁止推送

- **CI 流程**（GitHub Actions/GitLab CI）：
  1. 代码检出
  2. 安装依赖
  3. 执行 ESLint/Prettier
  4. 执行单元测试
  5. 构建镜像（可选）
  6. 执行集成测试（可选）
  7. 部署至测试环境（可选）

# 十二、发布与部署流程规范

## 12.1 发布流程

### 12.1.1 发布前检查清单

功能上线前需完成以下检查项：

| 序号 | 检查项 | 检查标准 | 执行人 |
|------|--------|----------|--------|
| 1 | 代码已通过 ESLint/Prettier 校验 | 无报错、无警告 | 开发者 |
| 2 | 单元测试覆盖率达标 | 核心模块 ≥ 80% | 开发者 |
| 3 | 代码审查已通过 | ≥ 1 人 approval | 审查者 |
| 4 | 接口文档已更新 | 与代码保持同步 | 开发者 |
| 5 | 测试用例全部通过 | 测试报告确认 | 测试人员 |
| 6 | 性能测试通过 | 响应时间符合要求 | 测试人员 |
| 7 | 安全扫描通过 | 无高危漏洞 | 安全负责人 |
| 8 | 回滚方案已准备 | 可快速回滚至上一版本 | 运维人员 |
| 9 | 监控告警已配置 | 关键指标已纳入监控 | 运维人员 |
| 10 | 运维文档已更新 | 部署配置、注意事项齐全 | 开发者 |

### 12.1.2 发布流程

```plain text
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  代码冻结   │ -> │  构建打包   │ -> │  预发布测试 │ -> │  生产发布   │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
       ↓                  ↓                  ↓                  ↓
  停止新功能开发      自动化构建镜像      隔离环境验证       灰度/全量发布
```

1. **代码冻结**：发布窗口期停止新功能代码合并，仅修复 Bug
2. **构建打包**：CI 自动构建，生成部署包或 Docker 镜像
3. **预发布测试**：在预发布环境进行最后一轮验证
4. **生产发布**：按照发布策略进行部署

## 12.2 部署策略

### 12.2.1 部署方式

| 部署方式 | 说明 | 适用场景 |
|----------|------|----------|
| 蓝绿部署 | 两套环境切换，无停机时间 | 高可用核心服务 |
| 灰度发布 | 新版本逐步放量，降低风险 | 新功能、重大更新 |
| 滚动部署 | 逐个实例更新，零停机 | 容器化部署 |
| 金丝雀发布 | 先面向小部分用户，观察反馈 | 高风险功能 |

### 12.2.2 灰度发布流程

```plain text
1. 新版本部署至灰度环境（10% 流量）
2. 监控核心指标（错误率、响应时间、转化率）
3. 观察 30 分钟，无异常则扩大至 50%
4. 继续观察，无异常则扩大至 100%
5. 旧版本完全下线
6. 如发现异常，立即切换回旧版本
```

### 12.2.3 发布窗口

- 常规发布：每周指定窗口期（如周二、周四 20:00-22:00）
- 紧急发布：故障修复不受窗口限制，但需事后复盘
- 发布前需在群内通知相关人员

## 12.3 回滚策略

### 12.3.1 回滚触发条件

| 条件 | 阈值 | 响应级别 |
|------|------|----------|
| 错误率突增 | > 2% | 立即回滚 |
| 响应时间超标 | P99 > 5s | 立即回滚 |
| 核心功能异常 | 阻断性 Bug | 立即回滚 |
| 性能下降 | 下降 > 30% | 评估后回滚 |

### 12.3.2 回滚流程

```plain text
1. 发现异常，触发告警
2. 值班人员确认问题
3. 决策是否回滚（影响范围 × 修复时间）
4. 执行回滚操作（保留当前版本备份）
5. 验证回滚后服务正常
6. 通知相关人员
7. 记录故障报告
```

### 12.3.3 回滚操作

```bash
# Docker 镜像回滚
docker tag [旧版本镜像]:latest [应用名]:latest
docker-compose up -d [应用名]

# Kubernetes 回滚
kubectl rollout undo deployment/[应用名]

# Git 回滚
git revert [问题提交]
git push origin develop
```

## 12.4 容器化部署规范

### 12.4.1 Dockerfile 规范

- 基础镜像使用官方稳定版本（如 `node:18-alpine`）
- 最小化镜像大小，多阶段构建
- 不在镜像中包含敏感信息
- 设置非 root 用户运行

```dockerfile
# 多阶段构建示例
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

### 12.4.2 Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## 12.5 部署监控

- **部署通知**：每次部署通过钉钉/企业微信群通知
- **部署日志**：记录每次部署的时间、版本、操作人、结果
- **部署成功率**：月度统计，目标是 ≥ 99%
- **部署频率**：鼓励小批量、高频部署，减少单次变更风险

## 12.6 环境配置管理

- **环境隔离**：开发、测试、预发布、生产环境严格隔离
- **配置注入**：敏感配置通过环境变量或密钥管理服务注入
- **配置版本化**：基础设施配置（如 Terraform）纳入版本控制
- **配置变更**：生产环境配置变更需记录在案，经过审批

# 十三、性能优化规范

## 13.1 性能指标定义

### 13.1.1 核心指标

| 指标 | 说明 | 达标标准 |
|------|------|----------|
| TTFB | 首字节时间 | ≤ 500ms |
| FCP | 首次内容绘制 | ≤ 1.5s |
| LCP | 最大内容绘制 | ≤ 2.5s |
| TTI | 可交互时间 | ≤ 3.5s |
| CLS | 累积布局偏移 | ≤ 0.1 |
| API 响应时间 | 接口返回时间 | P95 ≤ 500ms |
| 错误率 | 请求失败比例 | ≤ 0.1% |

### 13.1.2 性能测试要求

- **负载测试**：模拟预期流量 1.5 倍的并发压力
- **压力测试**：持续施加压力，测试系统极限
- **稳定性测试**：长期运行测试，检测内存泄漏等问题

## 13.2 前端性能优化

### 13.2.1 资源优化

- **代码分割**：使用动态导入实现按需加载
- **Tree Shaking**：移除未使用的代码
- **资源压缩**：HTML/CSS/JS 开启 Gzip/Brotli 压缩
- **图片优化**：
  - 使用 WebP 格式，体积更小
  - 按需加载（懒加载）
  - 响应式图片（srcset）
  - 压缩图片质量（Icon ≤ 50KB，图片 ≤ 200KB）

### 13.2.2 缓存策略

| 资源类型 | 缓存策略 | max-age |
|----------|----------|---------|
| HTML | 协商缓存 | - |
| JavaScript/CSS | 强缓存 + hash | 1 年 |
| 图片/字体 | 强缓存 | 1 年 |
| API 响应 | 协商缓存/禁用 | 视情况 |

### 13.2.3 渲染优化

- 减少重排、重绘，使用 CSS transform/opacity
- 长列表使用虚拟滚动（Virtual Scrolling）
- 使用 React.memo/Vue computed 避免不必要的重渲染
- 避免在渲染过程中进行复杂计算

### 13.2.4 网络优化

- 使用 CDN 加速静态资源
- 预加载关键资源（`<link rel="preload">`）
- 减少 HTTP 请求次数（合并资源）
- 使用 HTTP/2 多路复用

## 13.3 后端性能优化

### 13.3.1 数据库优化

- **索引优化**：
  - 为高频查询字段添加索引
  - 避免在索引列上使用函数
  - 定期分析慢查询日志

- **查询优化**：
  - 避免 SELECT *，只查询必要字段
  - 避免 N+1 查询，使用批量查询或预加载
  - 大数据量分页使用游标分页替代 OFFSET

- **读写分离**：主库处理写操作，从库处理读操作

### 13.3.2 缓存策略

- **多级缓存**：
  - 本地缓存（内存）- 热数据
  - 分布式缓存（Redis）- 共享数据
  - HTTP 缓存 - 静态资源

- **缓存更新**：
  - Write-Through：同步写入
  - Write-Behind：异步写入
  - Cache-Aside：先查缓存，查不到再查库

### 13.3.3 接口优化

- 避免同步调用多个外部接口，使用并发请求
- 对耗时操作使用异步处理（消息队列）
- 合理使用批量接口，减少请求次数
- 对大数据进行分页或流式返回

## 13.4 架构优化

### 13.4.1 服务拆分

- 按照业务域拆分微服务/模块
- 独立部署，独立扩展
- 服务间通过 API 通信，降低耦合

### 13.4.2 负载均衡

- 使用负载均衡器分发流量
- 健康检查机制，自动剔除故障节点
- 根据服务能力分配权重

### 13.4.3 限流与熔断

```javascript
// 限流示例（Redis + Lua）
const luaScript = `
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local expire = tonumber(ARGV[2])
local current = redis.call('get', key)

if current and tonumber(current) >= limit then
  return 0
else
  redis.call('incr', key)
  if tonumber(current) == 0 then
    redis.call('expire', key, expire)
  end
  return 1
end
`;
```

- **限流策略**：令牌桶、滑动窗口
- **熔断策略**：连续失败 N 次后熔断，恢复后逐步放行
- **降级策略**：熔断后返回兜底数据/缓存数据

## 13.5 性能监控

### 13.5.1 APM 工具

使用应用性能监控工具（免费开源方案）：

| 工具 | 用途 | 部署方式 |
|------|------|----------|
| Prometheus | 指标采集与存储 | Docker |
| Grafana | 数据可视化 | Docker |
| Jaeger | 链路追踪 | Docker |
| SkyWalking | 全链路监控 | Docker |

### 13.5.2 监控指标

- **系统层**：CPU、内存、磁盘、网络
- **应用层**：QPS、响应时间、错误率
- **业务层**：关键转化率、用户行为埋点
- **数据库层**：连接数、慢查询、缓存命中率

### 13.5.3 告警规则

| 指标 | 阈值 | 告警级别 |
|------|------|----------|
| CPU 使用率 | > 80% | 警告 |
| 内存使用率 | > 85% | 警告 |
| 错误率 | > 1% | 严重 |
| 响应时间 P95 | > 2s | 警告 |
| QPS 下降 | < 正常值 50% | 严重 |

# 十四、前后端联调规范

## 14.1 联调流程

### 14.1.1 联调前准备

| 准备项 | 负责人 | 完成标准 |
|--------|--------|----------|
| 接口文档 | 后端 | Swagger/Apifox 文档完整 |
| 接口 Mock 数据 | 前端 | 使用工具生成模拟数据 |
| 数据结构确认 | 双方 | 字段类型、格式达成一致 |
| 联调环境 | 后端 | 接口服务可访问 |

### 14.1.2 联调流程

```plain text
1. 后端开发完成接口，文档同步更新
2. 前端使用 Mock 数据完成页面开发
3. 前后端约定联调时间
4. 联调环境部署后端服务
5. 前端切换至联调环境，调用真实接口
6. 发现问题现场沟通修复
7. 联调通过后签署联调确认单
```

## 14.2 接口定义规范

### 14.2.1 接口文档要求

接口文档需包含以下内容：

| 字段 | 说明 |
|------|------|
| 接口名称 | 简要描述接口功能 |
| 请求方式 | GET/POST/PUT/DELETE |
| 请求路径 | RESTful 风格 URL |
| 请求参数 | 参数名、类型、必填、说明 |
| 请求示例 | 完整的请求 JSON |
| 响应参数 | 字段名、类型、说明 |
| 响应示例 | 完整的响应 JSON |
| 错误码说明 | 可能的错误码及处理建议 |
| 认证方式 | Token/JWT/API Key 等 |

### 14.2.2 响应数据结构

```json
{
  "code": 20000,
  "message": "操作成功",
  "data": {
    "list": [],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100
    }
  },
  "timestamp": 1704067200000
}
```

## 14.3 数据 Mock 规范

### 14.3.1 Mock 数据管理

- Mock 数据存放于 `src/mock/` 目录
- 文件命名与接口路径对应，如 `user/list.json`
- Mock 数据需覆盖正常和异常场景

### 14.3.2 Mock 工具推荐

| 工具 | 用途 | 特点 |
|------|------|------|
| Mock.js | 前端 Mock | 语法简洁，支持随机数据 |
| JSON Server | 快速 REST API | 零代码创建 REST API |
| MSW | API 拦截 | 拦截请求，返回模拟响应 |
| Apifox | 接口管理 | 支持接口文档与 Mock 一体 |

### 14.3.3 Mock 数据示例

```javascript
// src/mock/user/list.js
export default {
  'GET /api/users': {
    code: 20000,
    message: '获取成功',
    'data|10': [{
      'id|+1': 1,
      'name': '@CNAME',
      'email': '@EMAIL',
      'status|0-1': 0,
      'createdAt': '@DATETIME'
    }],
    'data.pagination': {
      page: 1,
      pageSize: 10,
      total: 100
    }
  }
};
```

## 14.4 联调问题处理

### 14.4.1 常见问题分类

| 问题类型 | 典型表现 | 处理方式 |
|----------|----------|----------|
| 参数错误 | 400 Bad Request | 检查参数类型、必填项 |
| 权限错误 | 401 Unauthorized | 确认 Token 有效性 |
| 业务错误 | 业务状态码异常 | 后端检查业务逻辑 |
| 跨域错误 | CORS 错误 | 后端配置 CORS |
| 数据格式 | 解析错误 | 确认 Content-Type |

### 14.4.2 联调问题记录

```markdown
### 联调问题记录

| 序号 | 日期 | 问题描述 | 责任方 | 处理状态 |
|------|------|----------|--------|----------|
| 1 | 2026-01-30 | 用户列表接口返回空数组 | 后端 | 已修复 |
| 2 | 2026-01-30 | 分页参数未生效 | 后端 | 已修复 |
```

## 14.5 接口测试与验收

### 14.5.1 接口测试用例

| 用例编号 | 用例名称 | 测试步骤 | 预期结果 |
|----------|----------|----------|----------|
| API_TC_001 | 正常查询 | GET /api/users?page=1 | 返回用户列表 |
| API_TC_002 | 异常参数 | GET /api/users?page=abc | 返回参数错误 |
| API_TC_003 | 未授权访问 | GET /api/users (无 Token) | 返回 401 |
| API_TC_004 | 权限不足 | GET /api/admin (普通用户) | 返回 403 |

### 14.5.2 联调验收标准

- [ ] 所有接口文档字段与实际返回一致
- [ ] 正常场景页面功能完整
- [ ] 异常场景有合理提示
- [ ] 接口响应时间符合要求
- [ ] 无前端控制台错误

# 十五、附录

## 15.1 术语表

| 术语 | 说明 |
|------|------|
| snake_case | 小写下划线命名法，如 `user_name` |
| PascalCase | 首字母大写驼峰，如 `UserList` |
| RESTful | REST 风格的 API 设计规范 |
| CRUD | Create、Read、Update、Delete 增删改查操作 |
| CI/CD | 持续集成/持续部署 |
| ESLint | JavaScript 代码校验工具 |
| Prettier | 代码格式化工具 |

## 15.2 规范适配

本规范为通用框架，实际项目开发中，需结合具体技术栈（如前端 Vue/React、后端 Node.js/Java）、业务场景、团队协作模式适配细化，适配方案需同步更新至 docs/design 目录，经团队确认后执行。

## 15.3 规范更新

本规范将根据项目迭代、技术发展、团队反馈适时更新，更新后需通知所有团队成员，确保全员遵循最新规范。

## 15.4 生效日期

本规范自发布之日起生效。

> （注：文档部分内容可能由 AI 生成）
